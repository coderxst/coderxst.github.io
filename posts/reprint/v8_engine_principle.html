<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>v8引擎的运行原理 | 修远的小屋</title><meta name="author" content="coderxst"><meta name="copyright" content="coderxst"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文介绍了JavaScript引擎的基本原理和V8引擎的工作原理，包括词法分析器、语法分析器、字节码生成器和机器码生成器等组件。V8引擎采用垃圾回收机制来自动管理内存的分配和释放，其中采用了分代收集策略和其他算法。文章还详细介绍了V8引擎在JavaScript代码解析、编译和执行过程中的内存管理和垃圾回收机制，以及堆内存结构的划分和优化。"><meta property="og:type" content="article"><meta property="og:title" content="v8引擎的运行原理"><meta property="og:url" content="https://coderxst.github.io/posts/reprint/v8_engine_principle.html"><meta property="og:site_name" content="修远的小屋"><meta property="og:description" content="本文介绍了JavaScript引擎的基本原理和V8引擎的工作原理，包括词法分析器、语法分析器、字节码生成器和机器码生成器等组件。V8引擎采用垃圾回收机制来自动管理内存的分配和释放，其中采用了分代收集策略和其他算法。文章还详细介绍了V8引擎在JavaScript代码解析、编译和执行过程中的内存管理和垃圾回收机制，以及堆内存结构的划分和优化。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/07/v8.jpeg"><meta property="article:published_time" content="2023-09-08T13:06:36.000Z"><meta property="article:modified_time" content="2024-04-09T10:23:34.020Z"><meta property="article:author" content="coderxst"><meta property="article:tag" content="浏览器原理"><meta property="article:tag" content="v8引擎"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s1.imagehub.cc/images/2023/10/07/v8.jpeg"><link rel="shortcut icon" href="https://s1.imagehub.cc/images/2023/10/07/favicon.png"><link rel="canonical" href="https://coderxst.github.io/posts/reprint/v8_engine_principle.html"><link rel="preconnect" href="https://cdn.staticfile.org"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.16/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:{defaultEncoding:1,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: coderxst",link:"链接: ",source:"来源: 修远的小屋",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"top-center"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"v8引擎的运行原理",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-04-09 18:23:34"}</script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach((e=>{n.setAttribute(e,t[e])})),document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="referrer" content="no-referrer"><link rel="stylesheet" href="/css/blur_filter.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.imagehub.cc/images/2023/10/07/avator.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-newspaper"></i> <span>文章</span></a></li><li><a class="site-page child" href="/updates/"><i class="fa-fw fas fa-solid fa-house-chimney-window"></i> <span>小屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i> <span>照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://s1.imagehub.cc/images/2023/10/07/v8.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="修远的小屋"><img class="site-icon" src="https://s1.imagehub.cc/images/2023/10/07/favicon.png"><span class="site-name">修远的小屋</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-newspaper"></i> <span>文章</span></a></li><li><a class="site-page child" href="/updates/"><i class="fa-fw fas fa-solid fa-house-chimney-window"></i> <span>小屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i> <span>照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">v8引擎的运行原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-08T13:06:36.000Z" title="发表于 2023-09-08 21:06:36">2023-09-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-09T10:23:34.020Z" title="更新于 2024-04-09 18:23:34">2024-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/reprint/">转载</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="v8引擎的运行原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote><h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>事实上我们编写的 JavaScript 无论你交给浏览器或者 Node 执行，最后都是需要被 CPU 执行的；但是 CPU 只认识自己的指令集，实际上是机器语言，才能被 CPU 所执行；所以我们需要 JavaScript 引擎帮助我们将 JavaScript 代码翻译</p></blockquote><hr><h2 id="一-认识-JavaScript-引擎"><a href="#一-认识-JavaScript-引擎" class="headerlink" title="一. 认识 JavaScript 引擎"></a>一. 认识 JavaScript 引擎</h2><h3 id="1-1-什么是-JavaScript-引擎"><a href="#1-1-什么是-JavaScript-引擎" class="headerlink" title="1.1. 什么是 JavaScript 引擎"></a>1.1. 什么是 JavaScript 引擎</h3><p>当我们编写 JavaScript 代码时，它实际上是一种高级语言，这种语言并不是机器语言。</p><ul><li><p>高级语言是设计给开发人员使用的，它包括了更多的抽象和可读性。</p></li><li><p>但是，计算机的 CPU 只能理解特定的机器语言，它不理解 JavaScript 语言。</p></li><li><p>这意味着，在计算机上执行 JavaScript 代码之前，必须将其转换为机器语言。</p></li></ul><p>这就是 JavaScript 引擎的作用：</p><ul><li><p>事实上我们编写的 JavaScript 无论你交给浏览器或者 Node 执行，最后都是需要被 CPU 执行的；</p></li><li><p>但是 CPU 只认识自己的指令集，实际上是机器语言，才能被 CPU 所执行；</p></li><li><p>所以我们需要 JavaScript 引擎帮助我们将 JavaScript 代码翻译成 CPU 指令来执行；</p></li></ul><p>比较常见的 JavaScript 引擎有哪些呢？</p><ul><li><p>SpiderMonkey：第一款 JavaScript 引擎，由 Brendan Eich 开发（也就是 JavaScript 作者）；</p></li><li><p>Chakra：微软开发，用于 IT 浏览器；</p></li><li><p>JavaScriptCore：WebKit 中的 JavaScript 引擎，Apple 公司开发；</p></li><li><p>V8：Google 开发的强大 JavaScript 引擎，也帮助 Chrome 从众多浏览器中脱颖而出；</p></li><li><p>等等…</p></li></ul><h3 id="1-2-浏览器内核和-JS-引擎关系"><a href="#1-2-浏览器内核和-JS-引擎关系" class="headerlink" title="1.2. 浏览器内核和 JS 引擎关系"></a>1.2. 浏览器内核和 JS 引擎关系</h3><p>我们前面学习了浏览器内核，那么浏览器内核和 JavaScript 引擎之间是什么样的关系呢？</p><ul><li><p>浏览器内核和 JavaScript 引擎之间有紧密的关系，因为 JavaScript 引擎是浏览器内核中的一个组件。</p></li><li><p>浏览器内核负责渲染网页，并在渲染过程中执行 JavaScript 代码。</p></li><li><p>JavaScript 引擎则是负责解析、编译和执行 JavaScript 代码的核心组件。</p></li></ul><p>以 WebKit 为例，它是一种开源的浏览器内核，最初由 Apple 公司开发，并被用于 Safari 浏览器中。</p><ul><li>WebKit 包含了一个 JavaScript 引擎，名为 JavaScriptCore，它负责解析、编译和执行 JavaScript 代码。</li></ul><p>WebKit 事实上由两部分组成的：</p><ul><li><p>WebCore：负责 HTML 解析、布局、渲染等等相关的工作。</p></li><li><p>JavaScriptCore：解析、执行 JavaScript 代码。</p></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXuvhnr0ibdSapFKPtd0U6zick0vX81TlApJZTepk8ryI7MicjmhdvO4aud4NvduwoJE4Fqj88XuCZtgIA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="WebKit 内核"></p><p>看到这里，学过小程序的同学有没有感觉非常的熟悉呢？</p><ul><li>在小程序中编写的 JavaScript 代码就是被 JSCore 执行的；</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXuvhnr0ibdSapFKPtd0U6zick0pSpqsKSlHnibnA9bsFD5DibTCowXIlT01areQfHzfLciapWpreNQHBI8g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="小程序的架构设计"></p><p>另外一个非常强大的 JavaScript 引擎就是 V8 引擎，也是我们今天要学习的重点。</p><h2 id="二-V8-引擎的运行原理"><a href="#二-V8-引擎的运行原理" class="headerlink" title="二. V8 引擎的运行原理"></a>二. V8 引擎的运行原理</h2><h3 id="2-1-V8-引擎的官方定义"><a href="#2-1-V8-引擎的官方定义" class="headerlink" title="2.1. V8 引擎的官方定义"></a>2.1. V8 引擎的官方定义</h3><p>V8 引擎是一款 Google 开源的高性能 JavaScript 和 WebAssembly 引擎，它是使用 C++编写的。</p><ul><li><p>V8 引擎的主要目标是提高 JavaScript 代码的性能和执行速度。</p></li><li><p>V8 引擎可以在多种操作系统上运行，包括 Windows 7 或更高版本、macOS 10.12+以及使用 x64、IA-32、ARM 或 MIPS 处理器的 Linux 系统。</p></li></ul><p>V8 引擎可以作为一个独立的应用程序运行，也可以嵌入到其他 C++应用程序中，例如 Node.js。</p><ul><li>由于 V8 引擎的开源性和高性能，许多现代浏览器都使用了 V8 引擎或其修改版本，以提供更快、更高效的 JavaScript 执行体验。</li></ul><h3 id="2-2-V8-引擎如何工作呢？"><a href="#2-2-V8-引擎如何工作呢？" class="headerlink" title="2.2. V8 引擎如何工作呢？"></a>2.2. V8 引擎如何工作呢？</h3><h4 id="2-2-1-V8-引擎的工作过程"><a href="#2-2-1-V8-引擎的工作过程" class="headerlink" title="2.2.1. V8 引擎的工作过程"></a>2.2.1. V8 引擎的工作过程</h4><p>我这里先给出一副 V8 引擎的工作图：</p><ul><li>后续我们会一点点解析它的工作过程</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXuvhnr0ibdSapFKPtd0U6zick0EL68Jf5OR8Qh3NPlxfKo5cePDRJw3ROCxNL44ictgnYGhuC1hyTAIcA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="V8 引擎的工作图"></p><p>整体流程如下：（先简单了解）</p><ol><li>词法分析：</li></ol><ul><li><p>首先，V8 引擎将 JavaScript 代码分成一个个标记或词法单元，这些标记是程序语法的最小单元。</p></li><li><p>例如，变量名、关键字、运算符等都是词法单元。</p></li><li><p>V8 引擎使用词法分析器来完成这个任务。</p></li></ul><ol start="3"><li>语法分析：</li></ol><ul><li><p>在将代码分成标记或词法单元之后，V8 引擎将使用语法分析器将这些标记转换为抽象语法树（AST）。</p></li><li><p>语法树是代码的抽象表示，它捕捉了代码中的结构和关系。</p></li><li><p>V8 引擎会检查代码是否符合 JavaScript 语言规范，并将其转换为抽象语法树。</p></li></ul><ol start="5"><li>字节码生成：</li></ol><ul><li><p>接下来，V8 引擎将从语法树生成字节码。</p></li><li><p>字节码是一种中间代码，它包含了执行代码所需的指令序列。</p></li><li><p>字节码是一种抽象的机器代码，它比源代码更接近机器语言，但仍需要进一步编译成机器指令。</p></li></ul><ol start="7"><li>机器码生成：</li></ol><ul><li><p>最后，V8 引擎将生成机器码，这是一种计算机可以直接执行的二进制代码。</p></li><li><p>V8 引擎使用即时编译器（JIT）来将字节码编译成机器码。</p></li><li><p>JIT 编译器将字节码分析为代码的热点部分，并生成高效的机器码，以提高代码的性能。</p></li></ul><h4 id="2-2-2-V8-引擎的架构设计"><a href="#2-2-2-V8-引擎的架构设计" class="headerlink" title="2.2.2. V8 引擎的架构设计"></a>2.2.2. V8 引擎的架构设计</h4><p>V8 引擎本身的源码非常复杂，大概有超过 100w 行 C++代码，通过了解它的架构，我们可以知道它是如何对 JavaScript 执行的：</p><p>Parse 模块会将 JavaScript 代码转换成 AST（抽象语法树），这是因为解释器并不直接认识 JavaScript 代码；</p><ul><li><p>如果函数没有被调用，那么是不会被转换成 AST 的；</p></li><li><p>Parse 的 V8 官方文档：<a target="_blank" rel="noopener" href="https://v8.dev/blog/scanner">https://v8.dev/blog/scanner</a></p></li></ul><p>Ignition 是一个解释器，会将 AST 转换成 ByteCode（字节码）</p><ul><li><p>同时会收集 TurboFan 优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）；</p></li><li><p>如果函数只调用一次，Ignition 会执行解释执行 ByteCode；</p></li><li><p>Ignition 的 V8 官方文档：<a target="_blank" rel="noopener" href="https://v8.dev/blog/ignition-interpreter">https://v8.dev/blog/ignition-interpreter</a></p></li></ul><p>TurboFan 是一个编译器，可以将字节码编译为 CPU 可以直接执行的机器码；</p><ul><li><p>如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过 TurboFan 转换成优化的机器码，提高代码的执行性能；</p></li><li><p>但是，机器码实际上也会被还原为 ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化（比如 sum 函数原来执行的是 number 类型，后来执行变成了 string 类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码；</p></li><li><p>TurboFan 的 V8 官方文档：<a target="_blank" rel="noopener" href="https://v8.dev/blog/turbofan-jit">https://v8.dev/blog/turbofan-jit</a></p></li></ul><p>另外，V8 引擎还包括了垃圾回收机制，用于自动管理内存的分配和释放。V8 引擎使用了一种名为“分代式垃圾回收”（Generational Garbage Collection）的技术，它将堆区分成新生代和老年代两个部分，分别使用不同的垃圾回收策略，以提高垃圾回收的效率。</p><ul><li>内存管理我们后续再单独来讨论学习。</li></ul><h3 id="2-3-V8-的转化代码过程"><a href="#2-3-V8-的转化代码过程" class="headerlink" title="2.3. V8 的转化代码过程"></a>2.3. V8 的转化代码过程</h3><p>比如我们有如下一段代码，V8 引擎是如何一步步帮我们转化的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;coderwhy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi &quot;</span> + name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHi</span>(name)</span><br></pre></td></tr></table></figure><p>下面是官方给出的一个图解：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXuvhnr0ibdSapFKPtd0U6zick02a4qyYY69Ijy32X4v9dWEw211TN71UD9OTUPuJS198jSnQMx5gvqnA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="官方图例"></p><h4 id="2-3-1-词法分析的过程"><a href="#2-3-1-词法分析的过程" class="headerlink" title="2.3.1. 词法分析的过程"></a>2.3.1. 词法分析的过程</h4><p>词法分析是将 JavaScript 代码转换成一系列标记的过程，它是编译过程的第一步。</p><ul><li>在 V8 引擎中，词法分析器会将 JavaScript 代码分解成一系列标识符、关键字、操作符和字面量等基本元素，以供后续的语法分析和代码生成等步骤使用。</li></ul><p>这里仅仅举一个例子，作为参考即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;const&#x27;</span>, value=<span class="string">&#x27;const&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;identifier&#x27;</span>, value=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;string&#x27;</span>, value=<span class="string">&#x27;&quot;coderwhy&quot;&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;console&#x27;</span>, value=<span class="string">&#x27;console&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;identifier&#x27;</span>, value=<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;identifier&#x27;</span>, value=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;function&#x27;</span>, value=<span class="string">&#x27;function&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;identifier&#x27;</span>, value=<span class="string">&#x27;sayHi&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;identifier&#x27;</span>, value=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;console&#x27;</span>, value=<span class="string">&#x27;console&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;identifier&#x27;</span>, value=<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;string&#x27;</span>, value=<span class="string">&#x27;&quot;Hi &quot;&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;identifier&#x27;</span>, value=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;identifier&#x27;</span>, value=<span class="string">&#x27;sayHi&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;identifier&#x27;</span>, value=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="title class_">Token</span>(type=<span class="string">&#x27;operator&#x27;</span>, value=<span class="string">&#x27;;&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-3-2-语法分析的过程"><a href="#2-3-2-语法分析的过程" class="headerlink" title="2.3.2. 语法分析的过程"></a>2.3.2. 语法分析的过程</h4><p>接下来我们可以根据上面得到的 tokens 代码，进行语法分析，生成对应的 AST 树。</p><p>在 V8 引擎中，语法分析的过程可以分为两个阶段：解析（Parsing）和预处理（Pre-parsing）。</p><p>解析阶段是将 tokens 转换成抽象语法树（AST）的过程，而预处理阶段则是在解析阶段之前进行的，用于预处理一些代码，如函数和变量声明等。</p><p>对于你提供的 JavaScript 代码，V8 引擎的解析和预处理过程如下所示：</p><p><strong>V8 引擎的解析和预处理过程如下所示：</strong></p><ol><li>预处理阶段</li></ol><ul><li><p>在预处理阶段，V8 引擎会扫描整个代码，查找函数和变量声明，并将其添加到当前作用域的符号表中。</p></li><li><p>在这个过程中，V8 引擎会同时进行词法分析和语法分析，生成一些中间表示，以便后续使用。</p></li><li><p>对于我们的代码，预处理阶段不会生成任何 AST 节点，因为它只包含了一个常量声明和一个函数声明，而没有变量声明（var 声明的变量）。</p></li></ul><ol start="2"><li>解析阶段</li></ol><ul><li><p>在解析阶段，V8 引擎会将 tokens 转换成 AST 节点，生成一棵抽象语法树（AST）。</p></li><li><p>AST 是一种树形结构，用于表示程序的语法结构，它包含了多种类型的节点，如表达式节点、语句节点和声明节点等。</p></li></ul><p>转化的 AST 树代码参考：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Program </span><br><span class="line">  └── VariableDeclaration (const name = <span class="string">&quot;coderwhy&quot;</span>) </span><br><span class="line">  └── ExpressionStatement (console.log(name)) </span><br><span class="line">  └── FunctionDeclaration (<span class="keyword">function</span> sayHi(name) &#123; ... &#125;)     </span><br><span class="line">      └── BlockStatement         </span><br><span class="line">          └── ExpressionStatement (console.log(<span class="string">&quot;Hi &quot;</span> + name)) </span><br><span class="line">  └── ExpressionStatement (sayHi(name))</span><br></pre></td></tr></table></figure><p>从 AST 树中可以看出，整个程序由一个 Program 节点和三个子节点组成。</p><ul><li><p>其中，第一个子节点是一个 VariableDeclaration 节点，表示常量声明语句；</p></li><li><p>第二个子节点是一个 ExpressionStatement 节点，表示 console.log 语句；</p></li><li><p>第三个子节点是一个 FunctionDeclaration 节点，表示函数声明语句。</p></li><li><p>FunctionDeclaration 节点包含一个 BlockStatement 子节点，表示函数体，其中包含一个 ExpressionStatement 节点，表示 console.log 语句。</p></li><li><p>最后一个子节点是一个 ExpressionStatement 节点，表示调用函数语句。</p></li></ul><h4 id="2-3-3-转化的字节码（了解）"><a href="#2-3-3-转化的字节码（了解）" class="headerlink" title="2.3.3. 转化的字节码（了解）"></a>2.3.3. 转化的字节码（了解）</h4><p>根据上面得到的 AST 树，我们可以将其转换成对应的字节码。在 V8 引擎中，字节码是一种中间表示，用于表示程序的执行流程和指令序列。</p><p>V8 引擎会将 AST 树转换成如下的字节码序列：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 字节码指令集</span></span><br><span class="line">[Constant name=<span class="string">&quot;coderwhy&quot;</span>]</span><br><span class="line">[SetLocal name]</span><br><span class="line">[GetLocal name]</span><br><span class="line">[LoadProperty console]</span><br><span class="line">[LoadProperty <span class="built_in">log</span>]</span><br><span class="line">[Call 1]</span><br><span class="line">[Constant Hi]</span><br><span class="line">[GetLocal name]</span><br><span class="line">[BinaryOperation +]</span><br><span class="line">[Call 1]</span><br><span class="line">[SetLocal sayHi]</span><br><span class="line">[GetLocal name]</span><br><span class="line">[GetLocal sayHi]</span><br><span class="line">[Call 1]</span><br><span class="line">[Return]</span><br></pre></td></tr></table></figure><p>根据上面生成的字节码，我们可以看到 V8 引擎生成的字节码指令集，每个指令都对应了一种操作，如 Constant、SetLocal、GetLocal 等等。下面是对字节码指令集的解释：</p><ul><li><p>Constant：将常量值压入操作数栈中。</p></li><li><p>SetLocal：将操作数栈中的值存储到本地变量中。</p></li><li><p>GetLocal：将本地变量的值压入操作数栈中。</p></li><li><p>LoadProperty：从对象中加载属性值，并将其压入操作数栈中。</p></li><li><p>Call：调用函数，并将返回值压入操作数栈中。</p></li><li><p>BinaryOperation：对两个操作数执行二元运算，并将结果压入操作数栈中。</p></li><li><p>Return：从当前函数中返回，并将返回值压入操作数栈中。</p></li></ul><p>由于字节码是一种中间表示，它可以跨平台运行，在不同的操作系统和硬件平台上都可以执行。这种跨平台的特性，使得 V8 引擎成为了一款非常流行的 JavaScript 引擎。</p><p>在 Node 环境中，我们可以通过如下命令查看到字节码：</p><ul><li>但是默认 Node 环境下是打印所有的字节码的，所以内容会非常多（了解即可）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --print-bytecode test.js</span><br></pre></td></tr></table></figure><h4 id="2-3-4-生成的机器码（了解）"><a href="#2-3-4-生成的机器码（了解）" class="headerlink" title="2.3.4. 生成的机器码（了解）"></a>2.3.4. 生成的机器码（了解）</h4><p>在 V8 引擎中，机器码是通过即时编译（Just-In-Time Compilation，JIT）技术生成的。</p><ul><li><p>JIT 编译是一种动态编译技术，它将字节码转换成本地机器码，并将其缓存起来以提高代码的执行速度和性能。</p></li><li><p>JIT 编译器可以根据运行时信息对代码进行优化，并且可以根据不同的平台和硬件生成对应的机器码。</p></li></ul><p>在 V8 引擎中，机器码的生成过程分为两个阶段：</p><ul><li><p>预编译（pre-compilation）和优化（optimization）。</p></li><li><p>预编译阶段会生成一些简单的机器码，用于快速执行代码；</p></li><li><p>优化阶段则会根据代码的运行时信息生成更优化的机器码，以提高代码的执行效率和性能。</p></li></ul><p><strong>具体的生成过程如下：</strong></p><ol><li>预编译阶段</li></ol><ul><li><p>在预编译阶段，V8 引擎会生成一些简单的机器码，用于快速执行代码。</p></li><li><p>这些机器码是基于字节码生成的，它们可以直接执行，并且具有一定的优化效果。</p></li><li><p>在这个阶段，V8 引擎会根据代码的运行时信息生成一些简单的机器码，如对象和数组的存取、字符串的拼接、函数的调用等。</p></li></ul><ol start="2"><li>优化阶段</li></ol><ul><li><p>在优化阶段，V8 引擎会根据代码的运行时信息生成更优化的机器码，以提高代码的执行效率和性能。</p></li><li><p>在这个阶段，V8 引擎会通过分析代码的执行路径、类型信息、控制流程等，生成一些高效的机器码，并且可以进行多次优化，以获得更高的性能。</p></li></ul><p>在优化阶段，V8 引擎会使用 TurboFan 编译器来生成机器码。</p><ul><li>TurboFan 是一个基于中间表示（Intermediate Representation，IR）的编译器，它可以将字节码转换成高效的机器码，并且可以进行多层次的优化，包括基于类型的优化、内联优化、控制流优化、垃圾回收优化等。</li></ul><p>通过机器码的生成过程，我们可以看到 V8 引擎是如何根据代码的运行时信息生成高效的机器码，并且可以多次优化，以获得更高的性能。</p><ul><li>在后续的执行过程中，V8 引擎会将机器码缓存起来，以提高代码的执行速度和性能。</li></ul><h2 id="三-V8-引擎的内存管理"><a href="#三-V8-引擎的内存管理" class="headerlink" title="三. V8 引擎的内存管理"></a>三. V8 引擎的内存管理</h2><h3 id="3-1-认识内存管理"><a href="#3-1-认识内存管理" class="headerlink" title="3.1. 认识内存管理"></a>3.1. 认识内存管理</h3><p>不管什么样的编程语言，在代码的执行过程中都是需要给它分配内存的，不同的是某些编程语言需要我们自己手动的管理内存，某些编程语言会可以自动帮助我们管理内存。</p><p>不管以什么样的方式来管理内存，<strong>内存的管理都会有如下的生命周期</strong>：</p><ul><li><p>第一步：分配申请你需要的内存（申请）；</p></li><li><p>第二步：使用分配的内存（存放一些东西，比如对象等）；</p></li><li><p>第三步：不需要使用时，对其进行释放；</p></li></ul><p>不同的编程语言对于第一步和第三步会有不同的实现：</p><ul><li><p>手动管理内存：比如 C、C++，包括早期的 OC，都是需要手动来管理内存的申请和释放的（malloc 和 free 函数）；</p></li><li><p>这种方式需要程序员手动管理内存，容易出现内存泄漏和野指针等问题，程序的稳定性和安全性有一定的风险。</p></li><li><p>自动管理内存：比如 Java、JavaScript、Python、Swift、Dart 等，它们有自动帮助我们管理内存；</p></li><li><p>在这些语言中，存在垃圾回收机制来自动回收不再使用的内存空间，程序员只需要正确地使用变量和对象等引用类型数据，垃圾回收器就会自动进行内存管理，释放不再被引用的内存空间。</p></li><li><p>这种方式可以避免内存泄漏和野指针等问题，提高了程序的稳定性和安全性。</p></li></ul><p>对于开发者来说，JavaScript 的内存管理是自动的、无形的。</p><ul><li><p>我们创建的原始值、对象、函数……这一切都会占用内存；</p></li><li><p>但是我们并不需要手动来对它们进行管理，JavaScript 引擎会帮助我们处理好它；</p></li></ul><h3 id="3-2-JS-的内存管理"><a href="#3-2-JS-的内存管理" class="headerlink" title="3.2. JS 的内存管理"></a>3.2. JS 的内存管理</h3><p>在 JavaScript 中，内存分为栈内存和堆内存两种类型。</p><ul><li><p>栈内存用于存储基本数据类型和引用类型的地址，它具有自动分配和自动释放的特点。</p></li><li><p>堆内存用于存储引用类型的对象和数组等数据结构，它需要手动分配和释放内存。</p></li></ul><p>在 JavaScript 中，使用 var、let 和 const 声明的变量都是存在栈内存中的。</p><ul><li><p>当我们声明一个变量时，JavaScript 引擎会在栈内存中为其分配一块空间，并将变量的值存储在该空间中。</p></li><li><p>当变量不再被引用时，JavaScript 引擎会自动将其释放掉，以回收其空间。</p></li></ul><p>在 JavaScript 中，创建的对象和数组等引用类型数据都是存在堆内存中的。</p><ul><li><p>当我们创建一个对象时，JavaScript 引擎会在堆内存中为其分配一块空间，并将其属性存储在该空间中。</p></li><li><p>当对象不再被引用时，垃圾回收器会自动将其标记为垃圾，并回收其空间。</p></li></ul><p><strong>为内存的大小是有限的，所以当内存不再需要的时候，我们需要对其进行释放，以便腾出更多的内存空间。</strong></p><p>在手动管理内存的语言中，我们需要通过一些方式自己来释放不再需要的内存，比如 free 函数：</p><ul><li><p>但是这种管理的方式其实非常的低效，影响我们编写逻辑的代码的效率；</p></li><li><p>并且这种方式对开发者的要求也很高，并且一不小心就会产生内存泄露和野指针的情况；</p></li><li><p>影响程序的稳定性和安全性，同时也会影响编写逻辑代码的效率；</p></li></ul><p>所以大部分现代的编程语言都是有自己的垃圾回收机制：</p><ul><li><p>垃圾回收的英文是 Garbage Collection，简称 GC；</p></li><li><p>对于那些不再使用的对象，我们都称之为是垃圾，它需要被回收，以释放更多的内存空间；</p></li><li><p>而我们的语言运行环境，比如 Java 的运行环境 JVM，JavaScript 的运行环境 js 引擎都会内存 <strong>垃圾回收器</strong>；</p></li><li><p>垃圾回收器我们也会简称为 GC，所以在很多地方你看到 GC 其实指的是垃圾回收器；</p></li></ul><p>但是这里又出现了另外一个很关键的问题：GC 怎么知道哪些对象是不再使用的呢？ 这里就要用到 GC 的实现以及对应的算法；</p><h3 id="3-3-常见的-GC-算法"><a href="#3-3-常见的-GC-算法" class="headerlink" title="3.3. 常见的 GC 算法"></a>3.3. 常见的 GC 算法</h3><h4 id="3-3-1-引用计数（Reference-counting）"><a href="#3-3-1-引用计数（Reference-counting）" class="headerlink" title="3.3.1. 引用计数（Reference counting）"></a>3.3.1. 引用计数（Reference counting）</h4><p>引用计数（Reference counting）是一种常见的垃圾回收算法。</p><ul><li><p>它的基本思想是在对象中添加一个引用计数器。</p></li><li><p>每当有一个指针引用该对象时，引用计数器就加一。</p></li><li><p>当指针不再引用该对象时，引用计数器就减一。</p></li><li><p>当引用计数器的值为 0 时，表示该对象不再被引用，可以被回收。</p></li></ul><p>引用计数算法的优点是实现简单，垃圾对象的回收及时，可以避免内存泄漏。</p><p>但是引用计数算法也有一些缺点。</p><ul><li><p>最大的缺点是很难解决循环引用问题。</p></li><li><p>如果两个对象相互引用，它们的引用计数器永远不会为 0，即使它们已经成为垃圾对象。</p></li><li><p>这种情况下，引用计数算法就无法回收它们，导致内存泄漏。</p></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXuvhnr0ibdSapFKPtd0U6zick0zjzOOKFRcnhQQ2JibKM6CoCKA9a0dBNMQH9z14pEFNe62PsdvTboj4g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="循环引用循环引用"></p><h4 id="3-3-2-标记清除（mark-Sweep）"><a href="#3-3-2-标记清除（mark-Sweep）" class="headerlink" title="3.3.2. 标记清除（mark-Sweep）"></a>3.3.2. 标记清除（mark-Sweep）</h4><p>标记清除（mark-Sweep）是一种常见的垃圾回收算法，其核心思想是可达性（Reachability）。算法的实现过程如下：</p><ol><li><p>设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象。</p></li><li><p>对于每一个找到的对象，标记为可达（mark），表示该对象正在使用中。</p></li><li><p>对于所有没有被标记为可达的对象，即不可达对象，就认为是不可用的对象，需要被回收。</p></li><li><p>回收不可达对象所占用的内存空间，并将其加入空闲内存池中，以备将来重新分配使用。</p></li></ol><p>标记清除算法可以很好地解决循环引用的问题，因为它只关注可达性，不会被循环引用的对象误判为可用对象。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXuvhnr0ibdSapFKPtd0U6zick0NJicnDQJ1bU00HDiaibkUkuPEJib33K1sQ3o5ibP9AFtUTjzfvUXwgvzshA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="标记清除算法"></p><p>但是这种算法也有一些缺点，最主要的是它的效率不高，因为在标记可达对象和回收不可达对象的过程中需要遍历整个对象图。</p><p>此外，标记清除算法还会造成内存碎片的问题，因为回收的内存空间不一定是连续的，导致大块的内存无法被分配使用。</p><h4 id="3-3-3-其他算法优化补充"><a href="#3-3-3-其他算法优化补充" class="headerlink" title="3.3.3. 其他算法优化补充"></a>3.3.3. 其他算法优化补充</h4><p>S 引擎比较广泛的采用的就是可达性中的标记清除算法，当然类似于 V8 引擎为了进行更好的优化，它在算法的实现细节上也会结合一些其他的算法。</p><p>标记整理（Mark-Compact）</p><ul><li><p>和“标记－清除”相似；</p></li><li><p>不同的是，回收期间同时会将保留的存储对象搬运汇集到连续的内存空间，从而整合空闲空间，避免内存碎片化；</p></li></ul><p>分代收集（Generational collection）—— 对象被分成两组：“新的”和“旧的”。</p><ul><li><p>许多对象出现，完成它们的工作并很快死去，它们可以很快被清理；</p></li><li><p>那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少；</p></li></ul><p>增量收集（Incremental collection）</p><ul><li><p>如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。</p></li><li><p>所以引擎试图将垃圾收集工作分成几部分来做，然后将这几部分会逐一进行处理，这样会有许多微小的延迟而不是一个大的延迟；</p></li></ul><p>闲时收集（Idle-time collection）</p><ul><li><p>垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</p></li><li><p>这种算法通常用于移动设备或其他资源受限的环境，以确保垃圾收集对用户体验的影响最小。</p></li></ul><h4 id="3-3-4-V8-引擎的内存图"><a href="#3-3-4-V8-引擎的内存图" class="headerlink" title="3.3.4. V8 引擎的内存图"></a>3.3.4. V8 引擎的内存图</h4><p>事实上，V8 引擎为了提供内存的管理效率，对内存进行非常详细的划分。（详细参考视频学习）</p><p>这幅图展示了一个堆（heap）的内存结构，下面是对每个内存块的解释：</p><ul><li><p>Old Space（老生代）：分配的内存较大，存储生命周期较长的对象，比如页面或者浏览器的长时间使用对象；</p></li><li><p>New Space（新生代）：分配的内存较小，存储生命周期较短的对象，比如临时变量、函数局部变量等；</p></li><li><p>Large Object Space（大对象）：分配的内存较大，存储生命周期较长的大型对象，比如大数组、大字符串等；</p></li><li><p>Code Space（代码空间）：存储编译后的函数代码和 JIT 代码；</p></li><li><p>Map Space（映射空间）：存储对象的属性信息，比如对象的属性名称、类型等信息；</p></li><li><p>Cell Space（单元格空间）：存储对象的一些元信息，比如字符串长度、布尔类型等信息。</p></li></ul><p>这些不同的内存块都有各自的特点和用途，V8 引擎会根据对象的生命周期和大小将它们分配到不同的内存块中，以优化内存的使用效率。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/O8xWXzAqXuvhnr0ibdSapFKPtd0U6zick0mYib1hwBYa8PKiarNuCRS8f7Mnr4rlkmcwSr0VWmXGZSVS1H8iaIn4fdw/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="V8 引擎的内存图"></p><blockquote><p>更多内容，关注公众号：coderwhy 或者添加我的微信：coderwhy666</p></blockquote><hr><p>文章转载于<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vUyAMn8uM00AkX5nIj73aw">coderwhy | JavaScript 高级系列（二） - V8 引擎的运行原理</a></p><hr></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/coderwhy">coderwhy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vUyAMn8uM00AkX5nIj73aw">https://mp.weixin.qq.com/s/vUyAMn8uM00AkX5nIj73aw</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">文章转载于[coderwhy | JavaScript 高级系列（二） - V8 引擎的运行原理](https://mp.weixin.qq.com/s/vUyAMn8uM00AkX5nIj73aw)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/browser-principle/">浏览器原理</a><a class="post-meta__tags" href="/tags/v8-engine/">v8引擎</a></div><div class="post_share"><div class="social-share" data-image="https://s1.imagehub.cc/images/2023/10/07/v8.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload='this.media="all"'><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/reprint/Javascript_operation_process_one.html" title="JavaScript的运行过程"><img class="cover" src="https://s1.imagehub.cc/images/2023/10/07/JavaScript.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaScript的运行过程</div></div></a></div><div class="next-post pull-right"><a href="/posts/reprint/browser_principles.html" title="深入浏览器的渲染原理"><img class="cover" src="https://s1.imagehub.cc/images/2023/10/07/b6b465a5d04733a62b8c463cce7ebdaa.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深入浏览器的渲染原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/reprint/browser_principles.html" title="深入浏览器的渲染原理"><img class="cover" src="https://s1.imagehub.cc/images/2023/10/07/b6b465a5d04733a62b8c463cce7ebdaa.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-08</div><div class="title">深入浏览器的渲染原理</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Waline</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.imagehub.cc/images/2023/10/07/avator.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">coderxst</div><div class="author-info__description">技术之窗映智慧，博客篇章展未来。 代码行间蕴含道，思辨之间见真理。 探索无垠宇宙间，分享科技新成果。 点滴积累成巨变，启迪心灵与思维。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/coderxst"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/coderxst" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:1968880532@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p style="text-indent:1.2em">修远的小屋正式上线, 欢迎大家的指导与交流!</p><p style="text-indent:1.2em" style="text-indent:1.2em">此版本只维护文章更新，体验更多功能请访问<a href="https://house.coderxst.top/" target="_blank">安知鱼版本：https://house.coderxst.top/</a></p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Excerpt"><span class="toc-text">Excerpt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E8%AE%A4%E8%AF%86-JavaScript-%E5%BC%95%E6%93%8E"><span class="toc-text">一. 认识 JavaScript 引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-JavaScript-%E5%BC%95%E6%93%8E"><span class="toc-text">1.1. 什么是 JavaScript 引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%92%8C-JS-%E5%BC%95%E6%93%8E%E5%85%B3%E7%B3%BB"><span class="toc-text">1.2. 浏览器内核和 JS 引擎关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-V8-%E5%BC%95%E6%93%8E%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">二. V8 引擎的运行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-V8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%98%E6%96%B9%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1. V8 引擎的官方定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-V8-%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E5%91%A2%EF%BC%9F"><span class="toc-text">2.2. V8 引擎如何工作呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-V8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-text">2.2.1. V8 引擎的工作过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-V8-%E5%BC%95%E6%93%8E%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.2.2. V8 引擎的架构设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-V8-%E7%9A%84%E8%BD%AC%E5%8C%96%E4%BB%A3%E7%A0%81%E8%BF%87%E7%A8%8B"><span class="toc-text">2.3. V8 的转化代码过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">2.3.1. 词法分析的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">2.3.2. 语法分析的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E8%BD%AC%E5%8C%96%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">2.3.3. 转化的字节码（了解）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E7%94%9F%E6%88%90%E7%9A%84%E6%9C%BA%E5%99%A8%E7%A0%81%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">2.3.4. 生成的机器码（了解）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-V8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">三. V8 引擎的内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%AE%A4%E8%AF%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">3.1. 认识内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-JS-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">3.2. JS 的内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B8%B8%E8%A7%81%E7%9A%84-GC-%E7%AE%97%E6%B3%95"><span class="toc-text">3.3. 常见的 GC 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%88Reference-counting%EF%BC%89"><span class="toc-text">3.3.1. 引用计数（Reference counting）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%EF%BC%88mark-Sweep%EF%BC%89"><span class="toc-text">3.3.2. 标记清除（mark-Sweep）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E8%A1%A5%E5%85%85"><span class="toc-text">3.3.3. 其他算法优化补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-V8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-text">3.3.4. V8 引擎的内存图</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/reprint/Alist_and_Lsky_image_hosting.html" title="使用Alist与Lsky搭建图床"><img src="https://s1.imagehub.cc/images/2024/04/09/5f344921b0c257a000cf59c967bad5cf.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="使用Alist与Lsky搭建图床"></a><div class="content"><a class="title" href="/posts/reprint/Alist_and_Lsky_image_hosting.html" title="使用Alist与Lsky搭建图床">使用Alist与Lsky搭建图床</a><time datetime="2023-12-31T12:30:02.000Z" title="发表于 2023-12-31 20:30:02">2023-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/reprint/Promises_A+_rule_implementation.html" title="Promises/A+规范的实现"><img src="https://s1.imagehub.cc/images/2023/11/03/bfcd144ab002594baa86b396731b7362.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Promises/A+规范的实现"></a><div class="content"><a class="title" href="/posts/reprint/Promises_A+_rule_implementation.html" title="Promises/A+规范的实现">Promises/A+规范的实现</a><time datetime="2023-11-02T12:45:56.000Z" title="发表于 2023-11-02 20:45:56">2023-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/reprint/Promise_usage_detail.html" title="Promise用法的详细解析"><img src="https://s1.imagehub.cc/images/2023/11/02/75686203432fa32c76f072346c4a0706.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Promise用法的详细解析"></a><div class="content"><a class="title" href="/posts/reprint/Promise_usage_detail.html" title="Promise用法的详细解析">Promise用法的详细解析</a><time datetime="2023-11-02T03:23:56.000Z" title="发表于 2023-11-02 11:23:56">2023-11-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://s1.imagehub.cc/images/2023/10/07/v8.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By coderxst</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://coderxst.github.io">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.10.0/js/utils.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.10.0/js/main.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.10.0/js/tw_cn.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.16/fancybox/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.bootcdn.net/ajax/libs/pangu/4.0.7/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><script>(()=>{const e=()=>{new Valine(Object.assign({el:"#vcomment",appId:"h1Boa35kjciWDhduqL62ehMI-gzGzoHsz",appKey:"Pk1AX2iaLQN0d0LYEWayqUPT",avatar:"monsterid",serverURLs:"https://h1boa35k.lc-cn-n1-shared.com",emojiMaps:"",path:window.location.pathname,visitor:!1},null))},t=async()=>{"function"==typeof Valine||await getScript("https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.16/Valine.min.js"),e()};btf.loadComment(document.getElementById("vcomment"),t)})()</script><script>(()=>{const t=()=>{Waline.init(Object.assign({el:"#waline-wrap",serverURL:"https://waline.coderxst.top",pageview:!1,dark:'html[data-theme="dark"]',path:window.location.pathname,comment:!1},null))},a=async()=>{"object"==typeof Waline||(await getCSS("https://cdn.staticfile.org/waline/2.15.5/waline.min.css"),await getScript("https://cdn.staticfile.org/waline/2.15.5/waline.min.js")),t()};window.loadOtherComment=a})()</script></div><script defer id="ribbon" src="https://cdn.bootcdn.net/ajax/libs/butterfly-extsrc/1.1.3/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="true" data-click="true"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.bootcdn.net/ajax/libs/butterfly-extsrc/1.1.3/canvas-nest.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.bootcdn.net/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0},react:{opacity:.7},log:!1})</script></body></html>