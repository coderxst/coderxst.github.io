<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Java集合 | 修远的小屋</title><meta name="author" content="coderxst"><meta name="copyright" content="coderxst"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="这篇文章全面总结了 Java 编程中关于 Collection 集合的重要知识点，深入探讨了集合框架的核心概念、常见集合类型及其特点，以及如何在实际编程中高效地应用这些集合类。"><meta property="og:type" content="article"><meta property="og:title" content="Java集合"><meta property="og:url" content="https://coderxst.github.io/posts/programming-language/java_collection.html"><meta property="og:site_name" content="修远的小屋"><meta property="og:description" content="这篇文章全面总结了 Java 编程中关于 Collection 集合的重要知识点，深入探讨了集合框架的核心概念、常见集合类型及其特点，以及如何在实际编程中高效地应用这些集合类。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/07/java.jpeg"><meta property="article:published_time" content="2023-07-17T11:48:18.000Z"><meta property="article:modified_time" content="2024-04-09T10:23:34.001Z"><meta property="article:author" content="coderxst"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s1.imagehub.cc/images/2023/10/07/java.jpeg"><link rel="shortcut icon" href="https://s1.imagehub.cc/images/2023/10/07/favicon.png"><link rel="canonical" href="https://coderxst.github.io/posts/programming-language/java_collection.html"><link rel="preconnect" href="https://cdn.staticfile.org"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.16/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:{defaultEncoding:1,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: coderxst",link:"链接: ",source:"来源: 修远的小屋",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"top-center"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Java集合",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-04-09 18:23:34"}</script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach((e=>{n.setAttribute(e,t[e])})),document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="referrer" content="no-referrer"><link rel="stylesheet" href="/css/blur_filter.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.imagehub.cc/images/2023/10/07/avator.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-newspaper"></i> <span>文章</span></a></li><li><a class="site-page child" href="/updates/"><i class="fa-fw fas fa-solid fa-house-chimney-window"></i> <span>小屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i> <span>照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://s1.imagehub.cc/images/2023/10/07/java.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="修远的小屋"><img class="site-icon" src="https://s1.imagehub.cc/images/2023/10/07/favicon.png"><span class="site-name">修远的小屋</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-newspaper"></i> <span>文章</span></a></li><li><a class="site-page child" href="/updates/"><i class="fa-fw fas fa-solid fa-house-chimney-window"></i> <span>小屋</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i> <span>照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java集合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-17T11:48:18.000Z" title="发表于 2023-07-17 19:48:18">2023-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-09T10:23:34.001Z" title="更新于 2024-04-09 18:23:34">2024-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/programming-language/">编程语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Java集合"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-集合概述"><a href="#1-集合概述" class="headerlink" title="1.集合概述"></a>1.集合概述</h2><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1.基本概念"></a>1.1.基本概念</h2><ul><li><p><strong>集合可以存储任意类型的对象，并且长度可变</strong></p></li><li><p>集合对象可以是<strong>任意的数据类型，并且长度可变</strong></p></li></ul><h3 id="1-2-集合分类"><a href="#1-2-集合分类" class="headerlink" title="1.2.集合分类"></a>1.2.集合分类</h3><table><thead><tr><th>单列集合Collection</th><th>双列集合Map</th></tr></thead><tbody><tr><td>单列集合根接口，用于存储一系列符合某种规则的元素</td><td>双列集合根接口，用于存储具有键(<code>Key</code>)、值(<code>Value</code>)映射关系的元素</td></tr><tr><td><code>Collection</code>集合有两个重要的子接口，分别是List和Set</td><td><code>Map</code>集合中每个元素都包含一对键值，并且Key唯一，在使用<code>Map</code>集合时通过指定的Key找到对应的·</td></tr><tr><td><code>List</code>集合的特点是元素有序、可重复。该接口的主要实现类有<code>ArrayList</code>和<code>LinkedList</code></td><td><code>Map</code>接口的主要实现类有<code>HashMap</code>和<code>TreeMap</code></td></tr><tr><td><code>Set</code>集合的特点是元素无序并且不可重复。该接口的主要实现类有<code>HashSet</code>和<code>TreeSet</code></td><td></td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/10/22/TO8apPtlNEo6Lvs.png" alt="图片1"></p><h2 id="2-Collection接口"><a href="#2-Collection接口" class="headerlink" title="2.Collection接口"></a>2.Collection接口</h2><table><thead><tr><th><strong>方法声明</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>boolean add(Object o)</td><td>向集合中添加一个元素</td></tr><tr><td>boolean addAll(Collection c)</td><td>将指定集合c中的所有元素添加到该集合中</td></tr><tr><td>void clear()</td><td>删除该集合中的所有元素</td></tr><tr><td>boolean remove(Object o)</td><td>删除该集合中指定的元素</td></tr><tr><td>boolean removeAll(Collection c)</td><td>删除该集合中包含指定集合c中的所有元素</td></tr><tr><td>boolean isEmpty()</td><td>判断该集合是否为空</td></tr><tr><td>boolean contains(Object o)</td><td>判断该集合中是否包含某个元素</td></tr><tr><td>boolean containsAll(Collection c)</td><td>判断该集合中是否包含指定集合c中的所有元素</td></tr><tr><td>Iterator iterator()</td><td>返回在该集合的元素上进行迭代的迭代器（Iterator），用于遍历该集合所有元素</td></tr><tr><td>int size()</td><td>获取该集合元素个数</td></tr><tr><td>Stream<e>stream()</e></td><td>将集合源转换为有序元素的流对象（JDK 8新方法）</td></tr></tbody></table><h2 id="3-List接口"><a href="#3-List接口" class="headerlink" title="3.List接口"></a>3.List接口</h2><h3 id="3-1-List接口简介"><a href="#3-1-List接口简介" class="headerlink" title="3.1. List接口简介"></a>3.1. List接口简介</h3><h4 id="3-1-1-定义"><a href="#3-1-1-定义" class="headerlink" title="3.1.1.定义"></a>3.1.1.定义</h4><ul><li>List接口继承自Collection接口，是单列集合的一个重要分支，习惯性的会将实现了List接口的对象称为List集合</li></ul><h4 id="3-1-2-特点"><a href="#3-1-2-特点" class="headerlink" title="3.1.2.特点"></a>3.1.2.特点</h4><ul><li><strong>List集合中允许出现重复元素</strong>，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引（类似于数组中的元素角标）来访问集合中的元素</li><li><strong>元素有序</strong>，<strong>存入顺序和取出顺序一致</strong></li></ul><h4 id="3-1-3-常用方法"><a href="#3-1-3-常用方法" class="headerlink" title="3.1.3.常用方法"></a>3.1.3.常用方法</h4><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>void add(int index,Object element)</td><td>将元素element插入在List集合的指定索引位置</td></tr><tr><td>boolean addAll(int index,Collection c)</td><td>将集合c包含的所有元素插入到List集合的指定索引位置</td></tr><tr><td>Object get(int index)</td><td>返回集合索引index处的元素</td></tr><tr><td>Object remove(int index)</td><td>删除index索引处的元素</td></tr><tr><td>Object set(int index, Object element)</td><td>将索引index处元素替换成element元素，并将替换后的元素返回</td></tr><tr><td>int indexOf(Object o)</td><td>返回对象o在List集合中首次出现的位置索引</td></tr><tr><td>int lastIndexOf(Object o)</td><td>返回对象o在List集合中最后一次出现的位置索引</td></tr><tr><td>List subList(int fromIndex, int toIndex)</td><td>返回从索引fromIndex（包括）到 toIndex（不包括）处所有元素集合组成的子集合</td></tr><tr><td>Object[] toArray()</td><td>将集合元素转换为数组</td></tr><tr><td>default void sort(Comparator&lt;? super E&gt; c)</td><td>根据指定的比较器规则对集合元素排序（JDK 8新方法）</td></tr></tbody></table><h3 id="3-2-ArrayList类"><a href="#3-2-ArrayList类" class="headerlink" title="3.2. ArrayList类"></a>3.2. ArrayList类</h3><h4 id="3-2-1-特点"><a href="#3-2-1-特点" class="headerlink" title="3.2.1.特点"></a>3.2.1.特点</h4><ul><li>ArrayList是List接口的一个实现类，它是程序中最常见的一种集合</li><li>ArrayList内部的数据存储结构是<strong>数组形式</strong></li><li><strong>不适合做大量的增删操作</strong></li><li><strong>遍历和查找元素时显得非常高效</strong></li></ul><h4 id="3-2-2-语法"><a href="#3-2-2-语法" class="headerlink" title="3.2.2.语法"></a>3.2.2.语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;stu1&quot;</span>);                 </span><br><span class="line">list.add(<span class="string">&quot;stu2&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;集合的长度：&quot;</span> + list.size());</span><br><span class="line">System.out.println(<span class="string">&quot;第2个元素是：&quot;</span> + list.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="3-3-LinkedList类"><a href="#3-3-LinkedList类" class="headerlink" title="3.3. LinkedList类"></a>3.3. LinkedList类</h3><h4 id="3-3-1-特点"><a href="#3-3-1-特点" class="headerlink" title="3.3.1.特点"></a>3.3.1.特点</h4><ul><li>内部包含有两个Node类型的first和last属性的<strong>双向循环链表结构</strong></li><li><strong>遍历和查找效率较低</strong></li><li><strong>增删操作表现出很高的效率</strong></li></ul><h4 id="3-3-2-底层原理"><a href="#3-3-2-底层原理" class="headerlink" title="3.3.2.底层原理"></a>3.3.2.底层原理</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/10/22/Q2vq1TXpFeVHmsn.png" alt="图片2"></p><ul><li><p>左图为新增元素，图中的元素1和元素2在集合中彼此为前后关系，在它们之间新增一个元素时，只需要让元素1记住它后面的元素是新元素，让元素2记住它前面的元素为新元素就可以了</p></li><li><p>右图为删除元素，要想删除元素1和元素2之间的元素3，只需要让元素1与元素2变成前后关系就可以了</p></li></ul><h4 id="3-3-3-特有方法"><a href="#3-3-3-特有方法" class="headerlink" title="3.3.3.特有方法"></a>3.3.3.特有方法</h4><table><thead><tr><th><strong>方法声明</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>void add(int index, E element)</td><td>在此列表中指定的位置插入指定的元素。</td></tr><tr><td>void addFirst(Object o)</td><td>将指定元素插入集合的开头</td></tr><tr><td>void addLast(Object o)</td><td>将指定元素添加到集合的结尾</td></tr><tr><td>Object getFirst()</td><td>返回集合的第一个元素</td></tr><tr><td>Object getLast()</td><td>返回集合的最后一个元素</td></tr><tr><td>Object removeFirst()</td><td>移除并返回集合的第一个元素</td></tr><tr><td>Object removeLast()</td><td>移除并返回集合的最后一个元素</td></tr><tr><td>boolean offer(Object o)</td><td>将指定元素添加到集合的结尾</td></tr><tr><td>boolean offerFirst(Object o)</td><td>将指定元素添加到集合的开头</td></tr><tr><td>boolean offerLast(Object o)</td><td>将指定元素添加到集合的结尾</td></tr><tr><td>Object peek()</td><td>获取集合的第一个元素</td></tr><tr><td>Object peekFirst()</td><td>获取集合的第一个元素</td></tr><tr><td>Object peekLast()</td><td>获取集合的最后一个元素</td></tr><tr><td>Object poll()</td><td>移除并返回集合的第一个元素</td></tr><tr><td>Object pollFirst()</td><td>移除并返回集合的第一个元素</td></tr><tr><td>Object pollLast()</td><td>移除并返回集合的最后一个元素</td></tr><tr><td>void push(Object o)</td><td>将指定元素添加到集合的开头</td></tr><tr><td>Object pop()</td><td>移除并返回集合的第一个元素</td></tr></tbody></table><h4 id="3-3-4-语法"><a href="#3-3-4-语法" class="headerlink" title="3.3.4.语法"></a>3.3.4.语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">link</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();  </span><br><span class="line">link.add(<span class="string">&quot;stu1&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;stu2&quot;</span>);</span><br><span class="line">link.offer(<span class="string">&quot;offer&quot;</span>);                <span class="comment">// 向集合尾部追加元素</span></span><br><span class="line">link.push(<span class="string">&quot;push&quot;</span>);                  <span class="comment">// 向集合头部添加元素</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> link.peek();        <span class="comment">//获取集合第一个元素</span></span><br><span class="line">link.removeFirst();                 <span class="comment">// 删除集合第一个元素</span></span><br><span class="line">link.pollLast();                    <span class="comment">// 删除集合最后一个元素</span></span><br></pre></td></tr></table></figure><h2 id="4-Collection集合遍历"><a href="#4-Collection集合遍历" class="headerlink" title="4.Collection集合遍历"></a>4.Collection集合遍历</h2><h3 id="4-1-Iterator遍历集合"><a href="#4-1-Iterator遍历集合" class="headerlink" title="4.1. Iterator遍历集合"></a>4.1. Iterator遍历集合</h3><h4 id="4-1-1-工作原理"><a href="#4-1-1-工作原理" class="headerlink" title="4.1.1.工作原理"></a>4.1.1.工作原理</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/10/22/vhoW5lLbwFGT6U3.png" alt="图片3"></p><ul><li><p>Iterator遍历集合时，<strong>内部采用指针的方式</strong>来跟踪集合中的元素。在调用next()方法之前，索引位于第一个元素之前，不指向任何元素</p></li><li><p>第一次调用next()方法后，索引会向后移动一位，指向第一个元素并将该元素返回</p></li><li><p>再次调用next()方法时，索引会指向第二个元素并将该元素返回</p></li><li><p>以此类推，<strong>直到hasNext()方法返回false</strong>，表示到达了集合的末尾终止对元素的遍历</p></li></ul><h4 id="4-1-2-实现"><a href="#4-1-2-实现" class="headerlink" title="4.1.2.实现"></a>4.1.2.实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">    list.add(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Iterator迭代器遍历list集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-注意"><a href="#4-1-3-注意" class="headerlink" title="4.1.3.注意"></a>4.1.3.注意</h4><ul><li><code>Iterator</code>迭代器对集合中的元素进行迭代时，如果调用了集合对象的remove()方法删除元素，会出现<code>ConcurrentModificationException</code>异常。</li></ul><h3 id="4-2-foreach遍历集合"><a href="#4-2-foreach遍历集合" class="headerlink" title="4.2. foreach遍历集合"></a>4.2. foreach遍历集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用增强版for遍历list集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (Object obj : list) &#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：<code>foreach</code>循环遍历集合和数组时，只能访问集合中的元素，不能对其中的元素进行修改</li></ul><h3 id="4-3-JDK8-—-foreach遍历集合"><a href="#4-3-JDK8-—-foreach遍历集合" class="headerlink" title="4.3. JDK8 —- foreach遍历集合"></a>4.3. JDK8 —- foreach遍历集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(obj -&gt; System.out.println(obj));</span><br></pre></td></tr></table></figure><h3 id="4-4-forEachRemaining"><a href="#4-4-forEachRemaining" class="headerlink" title="4.4.forEachRemaining"></a>4.4.forEachRemaining</h3><ul><li>JDK 8中还针<strong>对Iterator迭代器</strong>对象提供了一个<strong>forEachRemaining(Consumer action)方法来进行遍历</strong>，该方法同样需要一个函数式接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">it.forEachRemaining(obj -&gt; System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj));</span><br></pre></td></tr></table></figure><h2 id="5-Set接口"><a href="#5-Set接口" class="headerlink" title="5.Set接口"></a>5.Set接口</h2><h3 id="5-1-Set接口简介"><a href="#5-1-Set接口简介" class="headerlink" title="5.1. Set接口简介"></a>5.1. Set接口简介</h3><h4 id="5-1-1-特点"><a href="#5-1-1-特点" class="headerlink" title="5.1.1.特点"></a>5.1.1.特点</h4><ul><li>Set接口和List接口一样，同样继承自Collection接口</li><li>Set接口中的<strong>元素无序</strong>，并且都会以某种规则保证存入的元素<strong>不出现重复</strong></li></ul><h4 id="5-1-2-分类"><a href="#5-1-2-分类" class="headerlink" title="5.1.2.分类"></a>5.1.2.分类</h4><table><thead><tr><th>分类</th><th>简介</th></tr></thead><tbody><tr><td>HashSet</td><td>根据对象的哈希值来确定元素在集合中的存储的位置，因此具有良好的存取和查找性能</td></tr><tr><td>TreeSet</td><td>以二叉树的方式来存储元素，它可以实现对集合中的元素进行排序</td></tr></tbody></table><h3 id="5-2-HashSet类"><a href="#5-2-HashSet类" class="headerlink" title="5.2. HashSet类"></a>5.2. HashSet类</h3><h4 id="5-2-1-特点"><a href="#5-2-1-特点" class="headerlink" title="5.2.1.特点"></a>5.2.1.特点</h4><ul><li>HashSet是Set接口的一个实现类，它所存储的元素<strong>不可重复</strong>，并且<strong>无序</strong></li><li>当向HashSet集合中添加一个元素时，首<strong>先会调用该元素的hashCode()方法</strong>来确定元素的存储位置，然后<strong>再调用元素对象的equals()方法</strong>来确保该位置没有重复元素</li></ul><h4 id="5-2-2-存储原理"><a href="#5-2-2-存储原理" class="headerlink" title="5.2.2.存储原理"></a>5.2.2.存储原理</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/10/22/Wl1HpNIjkamMBsO.png" alt="set"></p><ul><li>在Java中，一些<strong>基本数据包装类、String类等</strong>都已经默认<strong>重写了<code>hashCode()</code>和<code>equals()</code>方法</strong></li><li>开发者向<code>HashSet</code>集合中添加自定义的数据类型，如<code>Student</code>类时，必须增加重写的<code>hashCode()</code>和<code>equals()</code>方法，才能保证数据的唯一性。</li></ul><h3 id="5-3-TreeSet类"><a href="#5-3-TreeSet类" class="headerlink" title="5.3. TreeSet类"></a>5.3. TreeSet类</h3><h4 id="5-3-1-特点"><a href="#5-3-1-特点" class="headerlink" title="5.3.1.特点"></a>5.3.1.特点</h4><ul><li><code>TreeSet</code>是<code>Set</code>接口的另一个实现类，它内部采用<strong>平衡二叉树</strong>来存储元素，来保证<code>TreeSet</code>集合中<strong>没有重复</strong>的元素，并且可以对元素<strong>进行排序</strong></li><li>二叉树就是<strong>每个节点最多有两个子节点的有序树</strong>，每个节点及其子节点组成的树称为子树，左侧的节点称为“左子树”，右侧的节点称为“右子树”，其中<strong>左子树上的元素小于它的根结点</strong>，而<strong>右子树上的元素大于它的根结点</strong></li></ul><h4 id="5-3-2-存储原理"><a href="#5-3-2-存储原理" class="headerlink" title="5.3.2.存储原理"></a>5.3.2.存储原理</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/10/22/VB7G4P2wLFvcZ3x.png" alt="TreeSet存储原理"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/10/22/WHcuqkK2j9hvVUE.png" alt="treeSet存储原理2"></p><h4 id="5-3-3-特有方法"><a href="#5-3-3-特有方法" class="headerlink" title="5.3.3.特有方法"></a>5.3.3.特有方法</h4><table><thead><tr><th><strong>方法声明</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>Object first()</td><td>返回TreeSet集合的首个元素</td></tr><tr><td>Object last()</td><td>返回TreeSet集合的最后一个元素</td></tr><tr><td>Object lower(Object o)</td><td>返回TreeSet集合中小于给定元素的最大元素，如果没有返回null</td></tr><tr><td>Object floor(Object o)</td><td>返回TreeSet集合中小于或等于给定元素的最大元素，如果没有返回null</td></tr><tr><td>Object higher(Object o)</td><td>返回TreeSet集合中大于给定元素的最小元素，如果没有返回null</td></tr><tr><td>Object ceiling(Object o)</td><td>返回TreeSet集合中大于或等于给定元素的最小元素，如果没有返回null</td></tr><tr><td>Object pollFirst()</td><td>移除并返回集合的第一个元素</td></tr><tr><td>Object pollLast()</td><td>移除并返回集合的最后一个元素</td></tr></tbody></table><h4 id="5-3-4-排序"><a href="#5-3-4-排序" class="headerlink" title="5.3.4.排序"></a>5.3.4.排序</h4><h5 id="5-3-4-1-基本概念"><a href="#5-3-4-1-基本概念" class="headerlink" title="5.3.4.1.基本概念"></a>5.3.4.1.基本概念</h5><ul><li>向TreeSet集合添加元素时，都会调用compareTo()方法进行比较排序，该方法是Comparable接口中定义的，因此要想对集合中的元素进行<strong>排序，就必须实现<code>Comparable</code>接口</strong></li><li>Java中大部分的类都实现了<code>Comparable</code>接口，并默认实现了接口中的<code>CompareTo()</code>方法，如<code>Integer</code>、<code>Double</code>和String<code>等</code></li></ul><h5 id="5-3-4-2-分类"><a href="#5-3-4-2-分类" class="headerlink" title="5.3.4.2.分类"></a>5.3.4.2.分类</h5><ul><li><strong>自然排序：</strong>要求存储的元素类必须实现<code>Comparable</code>接口，并重写<code>compareTo()</code>方法</li><li><strong>定制排序：</strong>要求自定义一个比较器，该比较器必须实现<code>Comparator</code>接口，并重写<code>compare()</code>方法，然后将该比较器作为参数传入集合的有参构造</li></ul><h5 id="5-3-4-2-主要区别"><a href="#5-3-4-2-主要区别" class="headerlink" title="5.3.4.2.主要区别"></a>5.3.4.2.主要区别</h5><table><thead><tr><th>自然排序</th><th>定制排序</th></tr></thead><tbody><tr><td>适合元素类本身未实现<code>Comparable</code>接口，无法进行比较</td><td>元素类本身实现<code>Comparable</code>接口</td></tr><tr><td>适合元素类实现的Comparable接口排序规则无法满足用户需求</td><td>依赖<code>compareTo()</code>方法的实现</td></tr><tr><td>会额外定义一个实现<code>Comparator</code>接口的比较器</td><td>实现<code>Comparable</code>接口排序规则比较单一，不利于后续改进</td></tr></tbody></table><h5 id="5-3-4-2-实现"><a href="#5-3-4-2-实现" class="headerlink" title="5.3.4.2.实现"></a>5.3.4.2.实现</h5><ul><li>自然排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Object&gt;&#123;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&quot;: &quot;</span> + age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.age - person.age &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.age - person.age == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(person.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		TreeSet&lt;Object&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Object&gt;();</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">13</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">23</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Charli&quot;</span>, <span class="number">13</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">13</span>));</span><br><span class="line">		System.out.println(ts);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定制排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Object&gt;&#123;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&quot;: &quot;</span> + age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object obj1, Object obj2)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> (Person) obj1;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> (Person) obj2;</span><br><span class="line">		<span class="keyword">if</span>(person1.age - person2.age &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(person1.age - person2.age == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> person1.name.compareTo(person2.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		TreeSet&lt;Object&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Object&gt;(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">13</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">23</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Charli&quot;</span>, <span class="number">13</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">13</span>));</span><br><span class="line">		System.out.println(ts);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Map接口"><a href="#6-Map接口" class="headerlink" title="6.Map接口"></a>6.Map接口</h2><h3 id="6-1-Map接口简介"><a href="#6-1-Map接口简介" class="headerlink" title="6.1. Map接口简介"></a>6.1. Map接口简介</h3><h4 id="6-1-1-特点"><a href="#6-1-1-特点" class="headerlink" title="6.1.1.特点"></a>6.1.1.特点</h4><ul><li><strong>双列集合</strong>，它的每个元素都包含一个键对象<code>Key</code>和值对象<code>Value</code>，键和值对象之间存在一种对应关系，称为<strong>映射</strong></li><li><code>Map</code>中的<strong>映射关系是一对一</strong>的，一个键对象<code>Key</code>对应唯一一个值对象<code>Value</code>，其中<strong>键对象Key和值对象Value可以是任意数据类型</strong>，并且键对象<strong>Key不允许重复</strong>，这样在访问Map集合中的元素时，只要指定了Key，就能找到对应的Value</li></ul><h3 id="6-1-2-常用方法"><a href="#6-1-2-常用方法" class="headerlink" title="6.1.2.常用方法"></a>6.1.2.常用方法</h3><table><thead><tr><th><strong>方法声明</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>void put(Object key, Object value)</td><td>向Map集合中添加指定键值映射的元素</td></tr><tr><td>int size()</td><td>返回Map集合键值对映射的个数</td></tr><tr><td>Object get(Object key)</td><td>返回指定键所映射的值，如果此映射不包含该键的映射关系，则返回null</td></tr><tr><td>boolean containsKey(Object key)</td><td>查看Map集合中是否存在指定的键对象key</td></tr><tr><td>boolean containsValue(Object value)</td><td>查看Map集合中是否存在指定的值对象value</td></tr><tr><td>Object remove(Object key)</td><td>删除并返回Map集合中指定键对象Key的键值映射元素</td></tr><tr><td>void clear()</td><td>清空整个Map集合中的键值映射元素</td></tr><tr><td>Set keySet()</td><td>以Set集合的形式返回Map集合中所有的键对象Key</td></tr><tr><td>Collection values()</td><td>以Collection集合的形式返回Map集合中所有的值对象Value</td></tr><tr><td>Set&lt;Map.Entry&lt;Key,Value&gt;&gt; entrySet()</td><td>将Map集合转换为存储元素类型为Map的Set集合</td></tr><tr><td>Object getOrDefault(Object key, Object defaultValue)</td><td>返回Map集合指定键所映射的值，如果不存在则返回默认值defaultValue（JDK 8新方法）</td></tr><tr><td>void forEach(BiConsumer action)</td><td>通过传入一个函数式接口对Map集合元素进行遍历（JDK 8新方法）</td></tr><tr><td>Object putIfAbsent(Object key, Object value)</td><td>向Map集合中添加指定键值映射的元素，如果集合中已存在该键值映射元素，则不再添加而是返回已存在的值对象Value（JDK 8新方法）</td></tr><tr><td>boolean remove(Object key, Object value)</td><td>删除Map集合中键值映射同时匹配的元素（JDK 8新方法）</td></tr><tr><td>boolean replace(Object key, Object value)</td><td>将Map集合中指定键对象Key所映射的值修改为value（JDK 8新方法）</td></tr></tbody></table><h3 id="6-2-HashMap类"><a href="#6-2-HashMap类" class="headerlink" title="6.2. HashMap类"></a>6.2. HashMap类</h3><h4 id="6-2-1-特点"><a href="#6-2-1-特点" class="headerlink" title="6.2.1.特点"></a>6.2.1.特点</h4><ul><li>HashMap集合是Map接口的一个实现类，它用于存储键值映射关系，该集合的<strong>键和值允许为空</strong>，但<strong>键不能重复</strong>，且<strong>集合中的元素是无序</strong>的</li><li>HashMap<strong>底层是由哈希表结构</strong>组成的，其实就是“<strong>数组+链表</strong>”的组合体，<strong>数组是<code>HashMap</code>的主体结构，链表则主要是为了解决哈希值冲突而存在的分支结构</strong>。正因为这样特殊的存储结构，<code>HashMap</code>集合对于元素的增、删、改、查操作表现出的<strong>效率都比较高</strong></li></ul><h4 id="6-2-2-内部结构"><a href="#6-2-2-内部结构" class="headerlink" title="6.2.2.内部结构"></a>6.2.2.内部结构</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/10/22/DB63Y1yivjLanUt.png" alt="HashMap内部结构"></p><ul><li>在哈希表结构中，主体结构为图中水平方向的<strong>数组</strong>结构，其长度称为HashMap集合的容量（capacity）</li><li>数组结构垂直对应的是<strong>链表</strong>结构，链表结构称为一个桶（bucket），每个桶的位置在集合中都有对应的桶值，用于快速定位集合元素添加、查找时的位置</li></ul><h4 id="6-2-3-存储原理"><a href="#6-2-3-存储原理" class="headerlink" title="6.2.3.存储原理"></a>6.2.3.存储原理</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/10/22/msn9H6LrI2GWQRV.png" alt="HashMap存储原理"></p><h4 id="6-2-4-注意"><a href="#6-2-4-注意" class="headerlink" title="6.2.4.注意"></a>6.2.4.注意</h4><ul><li><p>使用HashMap集合时，如果通过键对象k定位到的桶位置不含链表结构，那么对于查找、添加等操作很快；如果定位到的桶位置包含链表结构，对于添加操作，其时间复杂度依然不大，因为最新的元素会插入链表头部，只需要简单改变引用链即可；而对于查找操作来讲，此时就需要遍历链表，然后通过键对象k的equals(k)方法逐一查找比对。</p><p>所以，从性能方面考虑，HashMap中的链表出现越少，性能才会越好，这就要求HashMap集合中的桶越多越好。</p></li><li><p>HashMap根据实际情况，内部实现了动态地分配桶数量的策略。</p><p>通过new HashMap()方法创建HashMap时，会默认集合容量capacity大小为16，加载因子loadFactor为0.75（HashMap桶多少权衡策略的经验值），此时该集合桶的阀值就为12（容量capacity与加载因子loadFactor的乘积），如果向HashMap集合中不断添加完全不同的键值对&lt;k,v&gt;，当超过12个存储元素时，HashMap集合就会默认新增加一倍桶的数量（也就是集合的容量），此时集合容量就变为32。</p></li></ul><h4 id="6-2-4-LinkedHashMap"><a href="#6-2-4-LinkedHashMap" class="headerlink" title="6.2.4.LinkedHashMap"></a>6.2.4.LinkedHashMap</h4><ul><li><code>HashMap</code>集合并不保证集合元素存入和取出的顺序</li><li>如果想让这两个顺序一致，可以使用<code>LinkedHashMap</code>类，它是HashMap的子类。和<code>LinkedList</code>一样也使用双向链表来维护内部元素的关系，使<code>LinkedHashMap</code>元素迭代的顺序与存入的顺序一致</li><li>一般情况下，用的最多的是<code>HashMap</code>，在<code>Map</code>中插入、删除和定位元素，<code>HashMap</code> 是最好的选择。但如果需要输出的顺序和输入的相同，那么用<code>LinkedHashMap</code>可以实现，它还可以按读取顺序来排列</li></ul><h3 id="6-3-Map集合遍历"><a href="#6-3-Map集合遍历" class="headerlink" title="6.3. Map集合遍历"></a>6.3. Map集合遍历</h3><h4 id="6-3-1-Iterator迭代器"><a href="#6-3-1-Iterator迭代器" class="headerlink" title="6.3.1.Iterator迭代器"></a>6.3.1.Iterator迭代器</h4><ul><li>遍历思路：先将<code>Map</code>集合转换为<code>Iterator</code>接口对象，然后进行遍历。由于Map集合中元素是由<strong>键值对组成</strong>的，所以使用<code>Iterator</code>接口遍历<code>Map</code>集合时，会有两种将<code>Map</code>集合转换为<code>Iterator</code>接口对象再进行遍历的方法</li><li>遍历方法：<code>keySet()</code>方法和<code>entrySet()</code>方法</li></ul><h5 id="6-3-1-1-keySet-方法"><a href="#6-3-1-1-keySet-方法" class="headerlink" title="6.3.1.1.keySet()方法"></a>6.3.1.1.keySet()方法</h5><ul><li>先将Map集合中所有键对象转换为Set单列集合，接着将包含键对象的Set集合转换为Iterator接口对象，然后遍历Map集合中所有的键，再根据键获取相应的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();           <span class="comment">// 获取键的集合</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> keySet.iterator();     <span class="comment">// 迭代键的集合</span></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">      <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);   <span class="comment">// 获取每个键所对应的值</span></span><br><span class="line">      System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-3-1-2-entrySet-方法"><a href="#6-3-1-2-entrySet-方法" class="headerlink" title="6.3.1.2.entrySet()方法"></a>6.3.1.2.entrySet()方法</h5><ul><li>将原有Map集合中的键值对作为一个整体返回为Set集合，接着将包含键值对对象的Set集合转换为Iterator接口对象，然后获取集合中的所有的键值对映射关系，再从映射关系中取出键和值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> entrySet.iterator();                 <span class="comment">// 获取Iterator对象</span></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">      Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) (it.next());</span><br><span class="line">      <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();              <span class="comment">// 获取Entry中的键</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();        <span class="comment">// 获取Entry中的值</span></span><br><span class="line">      System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-2-JDK8提供的forEach"><a href="#6-3-2-JDK8提供的forEach" class="headerlink" title="6.3.2.JDK8提供的forEach"></a>6.3.2.JDK8提供的forEach</h4><ul><li>JDK 8中，根据<code>Lambda</code>表达式特性新增了一个f<code>orEach(BiConsumer action)</code>方法来遍历<code>Map</code>集合，该方法所需要的参数也是一个函数式接口，因此可以使用<code>Lambda</code>表达式的书写形式来进行集合遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key,value) -&gt; System.out.println(key + <span class="string">&quot;:&quot;</span> + value));</span><br></pre></td></tr></table></figure><h4 id="6-3-3-值遍历—values-方法"><a href="#6-3-3-值遍历—values-方法" class="headerlink" title="6.3.3.值遍历—values()方法"></a>6.3.3.值遍历—values()方法</h4><ul><li>在<code>Map</code>集合中，除了以上介绍的两种主要的遍历方式外，还提供了一个<code>values()</code>方法，通过这个方法可以直接获取Map中存储所有值的<code>Collection</code>集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values(); <span class="comment">// 获取Map集合中value值集合对象</span></span><br><span class="line">values.forEach(v -&gt; System.out.println(v));</span><br></pre></td></tr></table></figure><h3 id="6-4-TreeMap集合"><a href="#6-4-TreeMap集合" class="headerlink" title="6.4. TreeMap集合"></a>6.4. TreeMap集合</h3><ul><li>介绍： <code>TreeMap</code>集合是<code>Map</code>接口的另一个实现类，在<code>TreeMap</code>内部是通过二叉树的原理来保证键的唯一性，这与<code>TreeSet</code>集合存储的原理一样，因此<code>TreeMap</code>中<strong>所有的键是按照某种顺序排列的</strong></li><li>说明：为了实现<code>TreeMap</code>元素排序，可以参考<code>TreeSet</code> 集合排序方式，使用<strong>自然排序和定制排序</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;Luck&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>comparator</code>方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compara</span> <span class="params">(Object obj1, Object obj2)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> (String) obj1;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> (String) obj2;</span><br><span class="line">        <span class="keyword">return</span> key2.comparaTo(key1);	<span class="comment">//调用了String对象的comparaTo()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">CustomComparator</span>());</span><br><span class="line">        map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>, Jack);</span><br><span class="line">        map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;Luck&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印结果</span></span><br><span class="line"><span class="comment"> * &#123;1=Jack， 2=Rose, 3=Luck&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="6-5-Properties集合"><a href="#6-5-Properties集合" class="headerlink" title="6.5. Properties集合"></a>6.5. Properties集合</h3><ul><li>介绍： <code>Map</code>接口还有一个实现类<code>Hashtable</code>，它和<code>HashMap</code>十分相似，其中一个主要区别在于<code>Hashtable</code><strong>是线程安全的</strong></li><li>说明：<code>Hashtable</code>类有一个子类<code>Properties</code>，<code>Properties</code>主要用来<strong>存储字符串类型的键和值</strong>，在实际开发中，经常使用**<code>Properties</code>集合类<strong>来存取应用的</strong>配置项**</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line">puclic <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.通过Properties进行属性文件读取操作</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 加载读取的文件 test.properties</span></span><br><span class="line">        pps.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.properties&quot;</span>));</span><br><span class="line">        <span class="comment">// 遍历test.properties键值对元素信息</span></span><br><span class="line">        pps.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot; = &quot;</span> + value));</span><br><span class="line">        <span class="comment">// 2.通过Properties进行属性文件写入操作</span></span><br><span class="line">        <span class="comment">// 指定写入操作的文件名称和位置</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.properties&quot;</span>);</span><br><span class="line">        <span class="comment">// 向Properties类文件进行写入键值对信息</span></span><br><span class="line">        pps.setProperties(<span class="string">&quot;charset&quot;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 将此 Properties 集合中新增键值对信息写入配置文件</span></span><br><span class="line">        pps.store(out, <span class="string">&quot;新增charset编码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * language=chinese</span></span><br><span class="line"><span class="comment"> * Font-size=14px</span></span><br><span class="line"><span class="comment"> * Backgroup-color=red</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="7-泛型"><a href="#7-泛型" class="headerlink" title="7.泛型"></a>7.泛型</h2><h3 id="7-1-why"><a href="#7-1-why" class="headerlink" title="7.1.why"></a>7.1.why</h3><ul><li>集合中可以存储任意类型的对象元素，但是当把一个对象存入集合后，集合会“忘记”这个对象的类型，将该对象从集合中取出时，这个对象的编译类型就统一变成了<strong>Object类型</strong></li><li>在程序中无法确定一个集合中的元素到底是什么类型，那么在取出元素时，如果进行强制类型转换就很容易出错</li></ul><h3 id="7-2-语法"><a href="#7-2-语法" class="headerlink" title="7.2.语法"></a>7.2.语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;参数化类型&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;参数化类型&gt;();</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><h2 id="8-常用工具类"><a href="#8-常用工具类" class="headerlink" title="8.常用工具类"></a>8.常用工具类</h2><h3 id="8-1-Collections工具类"><a href="#8-1-Collections工具类" class="headerlink" title="8.1. Collections工具类"></a>8.1. Collections工具类</h3><h4 id="8-1-1-添加、排序常用方法"><a href="#8-1-1-添加、排序常用方法" class="headerlink" title="8.1.1.添加、排序常用方法"></a>8.1.1.添加、排序常用方法</h4><table><thead><tr><th><strong>方法声明</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>static<t>boolean addAll(Collection&lt;? super T&gt; c, T… elements)</t></td><td>将所有指定元素添加到指定集合c中</td></tr><tr><td>static void reverse(List list)</td><td>反转指定List集合中元素的顺序</td></tr><tr><td>static void shuffle(List list)</td><td>对List集合中的元素进行随机排序</td></tr><tr><td>static void sort(List list)</td><td>根据元素的自然顺序对List集合中的元素进行排序</td></tr><tr><td>static void swap(List list,int i,int j)</td><td>将指定List集合中角标i处元素和j处元素进行交换</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">improt java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;k&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span> + list);</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;反转后：&quot;</span> + list);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;按自然顺序排序后：&quot;</span> + list);</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.print(<span class="string">&quot;随机排序后：&quot;</span> + list);</span><br><span class="line">        Collections.swap(list, <span class="number">0</span>, list.size() - <span class="number">1</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;集合收尾交换后：&quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 排序前：[c, z, b, k]</span></span><br><span class="line"><span class="comment"> * 反转后：[k, b, z, c]</span></span><br><span class="line"><span class="comment"> * 按自然顺序排序后：[b, c, k, z]</span></span><br><span class="line"><span class="comment"> * 按随机顺序排序后：[b, z, k, c]</span></span><br><span class="line"><span class="comment"> * 集合收尾元素交换后：[c, z, k, b]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="8-1-2-查找、替换常用方法"><a href="#8-1-2-查找、替换常用方法" class="headerlink" title="8.1.2.查找、替换常用方法"></a>8.1.2.查找、替换常用方法</h4><table><thead><tr><th><strong>方法声明</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>static int binarySearch(List list,Object key)</td><td>使用二分法搜索指定对象在List集合中的索引，查找的List集合中的元素必须是有序的</td></tr><tr><td>static Object max(Collection col)</td><td>根据元素的自然顺序，返回给定集合中最大的元素</td></tr><tr><td>static Object min(Collection col)</td><td>根据元素的自然顺序，返回给定集合中最小的元素</td></tr><tr><td>static boolean replaceAll(List list,Object oldVal,Object newVal)</td><td>用一个新值newVal替换List集合中所有的旧值oldVal</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">improt java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        Collections.addAll(list, -<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的元素：&quot;</span> + lsit);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合中最大元素：&quot;</span> + Collections.max(list));</span><br><span class="line">        Systme.out.println(<span class="string">&quot;集合中最小元素：&quot;</span> + Collections.min(list));</span><br><span class="line">        Collections.replaceAll(list, <span class="number">8</span>, <span class="number">0</span>);	<span class="comment">//将集合中的8用0替换掉</span></span><br><span class="line">        System.out.println(<span class="string">&quot;替换后的集合：&quot;</span> + list);</span><br><span class="line">        collections.sort(list);	<span class="comment">//使用二分法查找前，必须保证元素有序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;集合排序后为：&quot;</span> + list);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Collections.binarySearch(list, <span class="number">9</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合通过二分查找方法查找元素9所在角标为：&quot;</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 集合中的元素：[-3, 2, 9, 5, 8]</span></span><br><span class="line"><span class="comment"> * 集合中的最大元素：9</span></span><br><span class="line"><span class="comment"> * 集合中的最小元素：-3</span></span><br><span class="line"><span class="comment"> * 替换后的集合：[-3, 2, 9, 5, 0]</span></span><br><span class="line"><span class="comment"> * 集合排序后为：[-3, 0, 2, 5, 9]</span></span><br><span class="line"><span class="comment"> * 集合通过二分查找方法查找元素9所在角标为：4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="8-2-Arrays工具类"><a href="#8-2-Arrays工具类" class="headerlink" title="8.2. Arrays工具类"></a>8.2. Arrays工具类</h3><ul><li><code>sort()</code> 排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;2, 3, 5, 8, 9&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>binarySearch(Object[] obj, Object key)</code> 用二分法查找<code>obj</code>中的<code>key</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(arr);</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;8的索引位为：&quot;</span> + index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;2, 3, 5, 8, 9&#125;</span></span><br><span class="line"><span class="comment">// 8的索引位为：3</span></span><br></pre></td></tr></table></figure><ul><li><code>copyOfRange(int[] original, int from, int to)</code> 复制数组的指定范围</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="type">int</span>[] copy = Arrays.copyOfRange(arr, <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line">System.out.println(copy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;8, 3, 5, 2&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>fill(Object[] a, Object value)</code> 用<code>value</code>把数组填充</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.fill(arr, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;6, 6, 6, 6, 6&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>asList()</code> 把Array转换为List</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.toList(array);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [9, 8, 3, 5, 2]</span></span><br></pre></td></tr></table></figure><ul><li><code>stream()</code> 创建<code>stream</code>流对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(array);</span><br><span class="line">stream.forEach(item -&gt; System.out.println(item + <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">// 9 8 3 5 2</span></span><br></pre></td></tr></table></figure><h2 id="9-JDK8-—-聚合操作"><a href="#9-JDK8-—-聚合操作" class="headerlink" title="9.JDK8 —- 聚合操作"></a>9.JDK8 —- 聚合操作</h2><h3 id="9-1-聚合操作简介"><a href="#9-1-聚合操作简介" class="headerlink" title="9.1. 聚合操作简介"></a>9.1. 聚合操作简介</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/10/23/GLnxOQerBAWDk3f.png" alt="聚合"></p><h3 id="9-2-创建Stream流对象"><a href="#9-2-创建Stream流对象" class="headerlink" title="9.2. 创建Stream流对象"></a>9.2. 创建Stream流对象</h3><ul><li>所有的<code>Collections</code>集合都可以使用<code>stream()</code>静态方法获取<code>Stream</code>流对象</li><li><code>Stream</code>接口的<code>of()</code>静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的<code>Stream</code>流对象</li><li><code>Arrays</code>工具类的<code>stream()</code>静态方法也可以获取数组元素的<code>Stream</code>流对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">array</span> <span class="operator">=</span> &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.使用stream()静态方法获取Stream流对象</span></span><br><span class="line">        Stream&lt;Integer&gt; stream1 = list.stream();</span><br><span class="line">        stream1.forEach(item -&gt; System.out.println(item + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.使用Stream接口的of()静态方法创建Stream流对象</span></span><br><span class="line">        Stream&lt;Integer&gt; stream2 = Stream.of(array);</span><br><span class="line">        stream2.forEach(item -&gt; System.out.println(item + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.使用Arrays数组工具类的stream()静态方法创建stream流对象</span></span><br><span class="line">        Stream&lt;Integer&gt; stream3 = Arrays.stream(array);</span><br><span class="line">        stream3.forEach(item -&gt; System.out.println(item + <span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：在进行聚合操作时，只是改变了<code>Stream</code>流对象中的数据，并不会改变原始集合或数组中的源数据</li></ul><h3 id="9-3-Stream流的常用方法"><a href="#9-3-Stream流的常用方法" class="headerlink" title="9.3. Stream流的常用方法"></a>9.3. Stream流的常用方法</h3><table><thead><tr><th><strong>方法声明</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>Stream<t>filter(Predicate&lt;? super T&gt; predicate)</t></td><td>将指定流对象中的元素进行过滤，并返回一个子流对象</td></tr><tr><td>Stream<r>map(Function&lt;? super T, ? extends R&gt; mapper)</r></td><td>将流中的元素按规则映射到另一个流中</td></tr><tr><td>Stream<t>distinct()</t></td><td>删除流中重复的元素</td></tr><tr><td>Stream<t>sorted()</t></td><td>将流中的元素按自然顺序排序</td></tr><tr><td>Stream<t>limit(long maxSize)</t></td><td>截取流中元素的长度</td></tr><tr><td>Stream<t>skip(long n)</t></td><td>丢弃流中前n个元素</td></tr><tr><td>static<t>Stream<t>concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</t></t></td><td>将两个流对象合并为一个流</td></tr><tr><td>long count()</td><td>统计流中元素的个数</td></tr><tr><td>R collect(Collector&lt;? super T, A, R&gt; collector)</td><td>将流中的元素收集到一个容器中（如集合）</td></tr><tr><td>Object[] toArray()</td><td>将流中的元素收集到一个数组中</td></tr><tr><td>void forEach(Consumer&lt;? super T&gt; action)</td><td>将流中的元素进行遍历</td></tr></tbody></table><ul><li><code>forEach()</code> 遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不保证元素的遍历过程在流中是被有序执行的</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line">stream.forEach(i -&gt; System.out.println(i));  <span class="comment">// 遍历并打印流元素</span></span><br></pre></td></tr></table></figure><ul><li><code>filter()</code> 过滤</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个Stream流中的元素进行筛选转换成另一个子集流</span></span><br><span class="line">Stream&lt;T&gt;filter(Predicate&lt;? <span class="built_in">super</span> T&gt;   predicate);</span><br><span class="line">stream.filter(i -&gt; i.startsWith(<span class="string">&quot;张&quot;</span>));  <span class="comment">// 筛选出以“张”开头的流元素</span></span><br></pre></td></tr></table></figure><ul><li><code>map()</code> 映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将流对象中的元素通过特定的规则进行修改然后映射为另一个流对象</span></span><br><span class="line">Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br><span class="line">stream.map(str -&gt; str.toUpperCase());</span><br><span class="line">stream.map(String::toUpperCase);  <span class="comment">// 将所有流元素字母转换为大写</span></span><br></pre></td></tr></table></figure><ul><li><code>limit()</code> 截取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于对流对象中的元素进行截取操作</span></span><br><span class="line"><span class="comment">// 在多数情况下，limit()方法会与skip()方法（跳过方法）组合使用，用于截取流对象中指定位置的多个元素</span></span><br><span class="line">Stream&lt;T&gt;  <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br><span class="line">stream.skip(<span class="number">1</span>)     <span class="comment">// 跳过流中的前1个元素</span></span><br><span class="line">      .limit(<span class="number">2</span>);    <span class="comment">// 截取剩余流中的前2个元素</span></span><br></pre></td></tr></table></figure><ul><li><code>collect()</code> 收集</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * collect()是十分有用的终结操作，它可以把Stream中的元素保存为另外一种形式，比如集合、字符串等</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Collector参数包含4种操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) supplier（初始构造器）</span></span><br><span class="line"><span class="comment"> * 2) accumulator（累加器）</span></span><br><span class="line"><span class="comment"> * 3) combiner（组合器）</span></span><br><span class="line"><span class="comment"> * 4）finisher（终结者）</span></span><br><span class="line"><span class="comment"> * 在JDK 8中的java.util.stream包下的Collectors类内置了各种复杂的收集操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;张小明&quot;</span>, <span class="string">&quot;张阳&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过filter()方法筛选出字符串中以“张”开头的元素</span></span><br><span class="line">        <span class="comment">// 通过collect()方法进行终结操作，将流元素收集到一个List集合中</span></span><br><span class="line">        List&lt;String&gt; list = stream1.filter(item -&gt; item.startWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">            					   .collect(Collectors.toList());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;张小明&quot;</span>, <span class="string">&quot;张阳&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过filter()方法筛选出字符串中以“张”开头的元素</span></span><br><span class="line">        <span class="comment">// 通过collect()方法进行终结操作，将流元素使用“and”连接收集到一个字符串中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> stream2.filter(item -&gt; item.startWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">            				   .collect(Collectors.joining(<span class="string">&quot;and&quot;</span>));</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [张三, 张小明, 张阳]</span></span><br><span class="line"><span class="comment"> * 张三 and 张小明 and 张阳</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="9-4-Parallel-Stream-并行流"><a href="#9-4-Parallel-Stream-并行流" class="headerlink" title="9.4. Parallel Stream (并行流)"></a>9.4. Parallel Stream (并行流)</h3><h4 id="9-4-1-串并流对比"><a href="#9-4-1-串并流对比" class="headerlink" title="9.4.1.串并流对比"></a>9.4.1.串并流对比</h4><ul><li>串行流(Serial Stream)：将源数据转换为一个流对象，然后在单线程下执行聚合操作的流（也就是单一管道流）</li><li>并行流(Parallel Stream)：将源数据分为多个子流对象进行多线程操作（也就是多个管道流），然后将处理的结果再汇总为一个流对象</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/10/23/MR5B7quGU4O2bDJ.png" alt="串并流"></p><h4 id="9-4-2-并行流创建"><a href="#9-4-2-并行流创建" class="headerlink" title="9.4.2.并行流创建"></a>9.4.2.并行流创建</h4><ul><li>通过<code>Collection</code>集合接口的<code>parallelStream()</code>方法直接将集合类型的源数据转变为<code>Stream</code>并行流</li><li>通过<code>BaseStream</code>接口的<code>parallel()</code>方法将<code>Stream</code>串行流转变为<code>Stream</code>并行流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;张小明&quot;</span>, <span class="string">&quot;张阳&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.直接使用Collection接口的parallelStream()创建并行流</span></span><br><span class="line">        Stream&lt;String&gt; paralleStream = list.parallelStream();</span><br><span class="line">        System.out.println(parallelStream.isParallel());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个Stream串行流</span></span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;张小明&quot;</span>, <span class="string">&quot;张阳&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.使用BaseStream接口的parallel()方法将串行流变为并行流</span></span><br><span class="line">        Stream&lt;String&gt; parallel = stream.parallel();</span><br><span class="line">        System.out.println(parallel.isParallel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印结果</span></span><br><span class="line"><span class="comment"> * true</span></span><br><span class="line"><span class="comment"> * true</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="9-4-3-注意"><a href="#9-4-3-注意" class="headerlink" title="9.4.3.注意"></a>9.4.3.注意</h4><ul><li><p>创建<code>Stream</code>流对象时，除非有特别声明，否则默认创建的都是串行流</p></li><li><p>使用<code>Stream</code>并行流在一定程度上可以提升程序的执行效率，但是<strong>在多线程执行就会出现线程安全</strong>这个大问题，所以为了能够在聚合操作中使用<code>Stream</code>并行流，<strong>前提是要执行操作的源数据在并行执行过程中不会被修改</strong></p></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://coderxst.github.io">coderxst</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://coderxst.github.io/posts/programming-language/java_collection.html">https://coderxst.github.io/posts/programming-language/java_collection.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coderxst.github.io" target="_blank">修远的小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://s1.imagehub.cc/images/2023/10/07/java.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload='this.media="all"'><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/programming-language/Java_io.html" title="Java的IO流"><img class="cover" src="https://s1.imagehub.cc/images/2023/10/07/java.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java的IO流</div></div></a></div><div class="next-post pull-right"><a href="/posts/programming-language/Java_class.html" title="Java常用类"><img class="cover" src="https://s1.imagehub.cc/images/2023/10/07/java.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java常用类</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/programming-language/Java_io.html" title="Java的IO流"><img class="cover" src="https://s1.imagehub.cc/images/2023/10/07/java.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-17</div><div class="title">Java的IO流</div></div></a></div><div><a href="/posts/programming-language/Java_gui.html" title="Java图形用户接口"><img class="cover" src="https://s1.imagehub.cc/images/2023/10/07/java.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-17</div><div class="title">Java图形用户接口</div></div></a></div><div><a href="/posts/programming-language/java_jdbc.html" title="JavaJDBC"><img class="cover" src="https://s1.imagehub.cc/images/2023/10/07/java.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-17</div><div class="title">JavaJDBC</div></div></a></div><div><a href="/posts/programming-language/Java_class.html" title="Java常用类"><img class="cover" src="https://s1.imagehub.cc/images/2023/10/07/java.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-17</div><div class="title">Java常用类</div></div></a></div><div><a href="/posts/programming-language/Java_object_1.html" title="Java面向对象(上)"><img class="cover" src="https://s1.imagehub.cc/images/2023/10/07/java.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-17</div><div class="title">Java面向对象(上)</div></div></a></div><div><a href="/posts/programming-language/Java_object_2.html" title="Java面向对象(下)"><img class="cover" src="https://s1.imagehub.cc/images/2023/10/07/java.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-17</div><div class="title">Java面向对象(下)</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Waline</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.imagehub.cc/images/2023/10/07/avator.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">coderxst</div><div class="author-info__description">技术之窗映智慧，博客篇章展未来。 代码行间蕴含道，思辨之间见真理。 探索无垠宇宙间，分享科技新成果。 点滴积累成巨变，启迪心灵与思维。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/coderxst"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/coderxst" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:1968880532@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p style="text-indent:1.2em">修远的小屋正式上线, 欢迎大家的指导与交流!</p><p style="text-indent:1.2em" style="text-indent:1.2em">此版本只维护文章更新，体验更多功能请访问<a href="https://house.coderxst.top/" target="_blank">安知鱼版本：https://house.coderxst.top/</a></p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-text">1.集合概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1.基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%9B%86%E5%90%88%E5%88%86%E7%B1%BB"><span class="toc-text">1.2.集合分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Collection%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.Collection接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-List%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-List%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="toc-text">3.1. List接口简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">3.1.1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E7%89%B9%E7%82%B9"><span class="toc-text">3.1.2.特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">3.1.3.常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-ArrayList%E7%B1%BB"><span class="toc-text">3.2. ArrayList类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E7%89%B9%E7%82%B9"><span class="toc-text">3.2.1.特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E8%AF%AD%E6%B3%95"><span class="toc-text">3.2.2.语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-LinkedList%E7%B1%BB"><span class="toc-text">3.3. LinkedList类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E7%89%B9%E7%82%B9"><span class="toc-text">3.3.1.特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">3.3.2.底层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-text">3.3.3.特有方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-%E8%AF%AD%E6%B3%95"><span class="toc-text">3.3.4.语法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Collection%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86"><span class="toc-text">4.Collection集合遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Iterator%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-text">4.1. Iterator遍历集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">4.1.1.工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.1.2.实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E6%B3%A8%E6%84%8F"><span class="toc-text">4.1.3.注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-foreach%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-text">4.2. foreach遍历集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-JDK8-%E2%80%94-foreach%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-text">4.3. JDK8 —- foreach遍历集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-forEachRemaining"><span class="toc-text">4.4.forEachRemaining</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Set%E6%8E%A5%E5%8F%A3"><span class="toc-text">5.Set接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Set%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="toc-text">5.1. Set接口简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E7%89%B9%E7%82%B9"><span class="toc-text">5.1.1.特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-%E5%88%86%E7%B1%BB"><span class="toc-text">5.1.2.分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-HashSet%E7%B1%BB"><span class="toc-text">5.2. HashSet类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E7%89%B9%E7%82%B9"><span class="toc-text">5.2.1.特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="toc-text">5.2.2.存储原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-TreeSet%E7%B1%BB"><span class="toc-text">5.3. TreeSet类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E7%89%B9%E7%82%B9"><span class="toc-text">5.3.1.特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="toc-text">5.3.2.存储原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-text">5.3.3.特有方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-%E6%8E%92%E5%BA%8F"><span class="toc-text">5.3.4.排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">5.3.4.1.基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-4-2-%E5%88%86%E7%B1%BB"><span class="toc-text">5.3.4.2.分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-4-2-%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-text">5.3.4.2.主要区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-4-2-%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.3.4.2.实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Map%E6%8E%A5%E5%8F%A3"><span class="toc-text">6.Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Map%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="toc-text">6.1. Map接口简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-%E7%89%B9%E7%82%B9"><span class="toc-text">6.1.1.特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">6.1.2.常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-HashMap%E7%B1%BB"><span class="toc-text">6.2. HashMap类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E7%89%B9%E7%82%B9"><span class="toc-text">6.2.1.特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">6.2.2.内部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="toc-text">6.2.3.存储原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-%E6%B3%A8%E6%84%8F"><span class="toc-text">6.2.4.注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-LinkedHashMap"><span class="toc-text">6.2.4.LinkedHashMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86"><span class="toc-text">6.3. Map集合遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">6.3.1.Iterator迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-1-1-keySet-%E6%96%B9%E6%B3%95"><span class="toc-text">6.3.1.1.keySet()方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-1-2-entrySet-%E6%96%B9%E6%B3%95"><span class="toc-text">6.3.1.2.entrySet()方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-JDK8%E6%8F%90%E4%BE%9B%E7%9A%84forEach"><span class="toc-text">6.3.2.JDK8提供的forEach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E5%80%BC%E9%81%8D%E5%8E%86%E2%80%94values-%E6%96%B9%E6%B3%95"><span class="toc-text">6.3.3.值遍历—values()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-TreeMap%E9%9B%86%E5%90%88"><span class="toc-text">6.4. TreeMap集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-Properties%E9%9B%86%E5%90%88"><span class="toc-text">6.5. Properties集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%B3%9B%E5%9E%8B"><span class="toc-text">7.泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-why"><span class="toc-text">7.1.why</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E8%AF%AD%E6%B3%95"><span class="toc-text">7.2.语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">8.常用工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">8.1. Collections工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E6%B7%BB%E5%8A%A0%E3%80%81%E6%8E%92%E5%BA%8F%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">8.1.1.添加、排序常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E6%9F%A5%E6%89%BE%E3%80%81%E6%9B%BF%E6%8D%A2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">8.1.2.查找、替换常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">8.2. Arrays工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-JDK8-%E2%80%94-%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-text">9.JDK8 —- 聚合操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E7%AE%80%E4%BB%8B"><span class="toc-text">9.1. 聚合操作简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%88%9B%E5%BB%BAStream%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-text">9.2. 创建Stream流对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-Stream%E6%B5%81%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">9.3. Stream流的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-Parallel-Stream-%E5%B9%B6%E8%A1%8C%E6%B5%81"><span class="toc-text">9.4. Parallel Stream (并行流)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1-%E4%B8%B2%E5%B9%B6%E6%B5%81%E5%AF%B9%E6%AF%94"><span class="toc-text">9.4.1.串并流对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%88%9B%E5%BB%BA"><span class="toc-text">9.4.2.并行流创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-3-%E6%B3%A8%E6%84%8F"><span class="toc-text">9.4.3.注意</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/reprint/Alist_and_Lsky_image_hosting.html" title="使用Alist与Lsky搭建图床"><img src="https://s1.imagehub.cc/images/2024/04/09/5f344921b0c257a000cf59c967bad5cf.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="使用Alist与Lsky搭建图床"></a><div class="content"><a class="title" href="/posts/reprint/Alist_and_Lsky_image_hosting.html" title="使用Alist与Lsky搭建图床">使用Alist与Lsky搭建图床</a><time datetime="2023-12-31T12:30:02.000Z" title="发表于 2023-12-31 20:30:02">2023-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/reprint/Promises_A+_rule_implementation.html" title="Promises/A+规范的实现"><img src="https://s1.imagehub.cc/images/2023/11/03/bfcd144ab002594baa86b396731b7362.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Promises/A+规范的实现"></a><div class="content"><a class="title" href="/posts/reprint/Promises_A+_rule_implementation.html" title="Promises/A+规范的实现">Promises/A+规范的实现</a><time datetime="2023-11-02T12:45:56.000Z" title="发表于 2023-11-02 20:45:56">2023-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/reprint/Promise_usage_detail.html" title="Promise用法的详细解析"><img src="https://s1.imagehub.cc/images/2023/11/02/75686203432fa32c76f072346c4a0706.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Promise用法的详细解析"></a><div class="content"><a class="title" href="/posts/reprint/Promise_usage_detail.html" title="Promise用法的详细解析">Promise用法的详细解析</a><time datetime="2023-11-02T03:23:56.000Z" title="发表于 2023-11-02 11:23:56">2023-11-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://s1.imagehub.cc/images/2023/10/07/java.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By coderxst</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://coderxst.github.io">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.10.0/js/utils.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.10.0/js/main.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-butterfly/4.10.0/js/tw_cn.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.16/fancybox/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.bootcdn.net/ajax/libs/pangu/4.0.7/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><script>(()=>{const e=()=>{new Valine(Object.assign({el:"#vcomment",appId:"h1Boa35kjciWDhduqL62ehMI-gzGzoHsz",appKey:"Pk1AX2iaLQN0d0LYEWayqUPT",avatar:"monsterid",serverURLs:"https://h1boa35k.lc-cn-n1-shared.com",emojiMaps:"",path:window.location.pathname,visitor:!1},null))},t=async()=>{"function"==typeof Valine||await getScript("https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.16/Valine.min.js"),e()};btf.loadComment(document.getElementById("vcomment"),t)})()</script><script>(()=>{const t=()=>{Waline.init(Object.assign({el:"#waline-wrap",serverURL:"https://waline.coderxst.top",pageview:!1,dark:'html[data-theme="dark"]',path:window.location.pathname,comment:!1},null))},a=async()=>{"object"==typeof Waline||(await getCSS("https://cdn.staticfile.org/waline/2.15.5/waline.min.css"),await getScript("https://cdn.staticfile.org/waline/2.15.5/waline.min.js")),t()};window.loadOtherComment=a})()</script></div><script defer id="ribbon" src="https://cdn.bootcdn.net/ajax/libs/butterfly-extsrc/1.1.3/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="true" data-click="true"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.bootcdn.net/ajax/libs/butterfly-extsrc/1.1.3/canvas-nest.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.bootcdn.net/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0},react:{opacity:.7},log:!1})</script></body></html>